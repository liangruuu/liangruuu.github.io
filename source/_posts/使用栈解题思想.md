---
title: 使用栈解题思想
tags:
  - 栈
categories:
  - 算法
abbrlink: ba10a29b
date: 2020-08-24 09:56:34
---

**栈作为一种数据结构能很好的和其他算法思想，如动态规划，滑动窗口等结合。**

<!-- more -->

**更新1：解题时要区分是使用单调栈还是栈，两者的区别就是如果题目在某一次数组元素的循环中，也就是某一次外层循环中涉及到对多个栈内元素进行操作，则就是单调栈的题目，否则就是栈的题目；如果使用单调栈则必写代码之二处为where，若为栈则必写代码之二处为if**

**判断一道题是否能用栈来实现需要基本满足以下几个条件，并且在解题的时候需要逐步分析**

1. 是否涉及到元素之间的**比较**：该点是第二点的前提
2. 是否涉及到**延迟比较**：延迟比较的意思是当我处理到某个元素，并且涉及到该元素与其他元素之间比较的时候，我不立刻进行而是把这个元素`保存`起来，等到时机成熟的时候才把他拿出来进行操作，保存用栈来说就`入栈(stack.push())`，把数据存进`"冰箱"`里，当需要拿出来比较的时候就使用`获取栈顶元素(stack.top())`。保存这种功能也是数组，队列，栈等数据结构所能提供的。**注：如果分析到第二部涉及到延迟比较的话，大概率就使用栈或者队列等数据结构来辅助解题了，都不用再分析第三步了**
3. 元素之间的比较是否只有**一次**：若元素之间的比较只有一次，那么我们在处理完某轮元素之间的比较之后就`放弃`该元素，因为永远不会再被用到，这里的`放弃`通俗化来说就是删除，而栈就是有`出栈(stack.pop())`这种操作
4. 是否涉及到了**逆序**操作，根据栈先入后出的性质能够很好地执行逆序操作

**使用栈时候需要注意的几点**

1. 不管题目是怎么样子的，如果用到了`栈`思想，在代码里**一定！一定！一定**会有

   1.  必写代码之一：对于原始数据的遍历，对元素数据里的每一个元素都进行栈操作
   2. 必写代码之二：`while(!stack.empty()) 或 if(!stack.empty())`，即判断栈非空
   3. 必写代码之三：`stack.top()`，即取出栈顶元素(**根据top()的语法是不出栈的**)进行比较操作，**这里的比较操作涉及到获取栈顶元素之后的具体比较逻辑，具体问题具体分析**

   4. 必写代码之四：`stack.pop()`，即出栈顶元素(**根据pop()的语法是单纯出栈不返回栈顶元素的**)，因为元素只比较一次，比较完之后就出栈

   5. 必写代码之五：`stack.push(xxx)`，即入栈，因为需要延迟比较，所以把元素先入栈保存起来等待日后使用

**反正做栈的题目想都不用想直接现在代码里写上以上的几份代码，只不过代码存在的地方还得具体问题具体分析。**

**以下为用栈做辅助数据结构的简易模板**

```c++
class Solution {
public:
    返回值 function(vector<T>& sources) {
        int len = sources.size();
        stack<T> st;
        for (int i = 0; i < sources.size(); ++i) {
            // soures[i] > soures[st.top()]为栈顶元素和当前数组处理元素之间的比较，这里仅是一个例子
            // 这里有一种简易判断循环条件的方法，就是判断当前扫描到的数组元素要怎样才能不经处理就可以直接执行第五步入栈
            // 那么循环条件就是该方法的反面
            // 例如果当前处理数组元素值 小于 栈顶元素的话就能直接入栈的话
            // 则while其中一个循环条件就为sources[i] >= sources[st.top()]
            while (!st.empty() && sources[i] >= sources[st.top()]) {
                // 3. 必写代码之三：取出栈顶元素
                T t = st.top(); 
                // 4. 必写代码之四：出栈
                st.pop();
                // 使用栈顶元素做一些具体操作
              	...
            }
            // 5. 必写代码之五：入栈
            // 根据大量题目的验证，栈的push操作绝大部分是固定在while循环外的
            // 也就是说不管有没有进行栈顶元素和当前数组元素的比较判断，栈的push操作可以无脑写在while循环体外的第一行
          	// 由于while的其中一个条件为!st.empty()，也就是说当栈为空的时候，这行代码还能保证无条件入栈一个初始元素
            st.push(i);
        }
        return 返回值;
    }
};
```



