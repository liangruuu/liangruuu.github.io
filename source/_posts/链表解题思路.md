---
title: 链表解题思路
tags:
  - 链表
categories:
  - 算法
abbrlink: fe00eebf
date: 2020-09-03 13:32:47
---

**跟链表相关的题目一般需要注意以下几点**

<!-- more -->

1. 当使用**迭代法**处理链表题时，在函数体最开始规定先构造虚拟头结点(dummyHead)；特别的，当时用**递归法**处理链表问题时不需要考虑构造虚拟头结点

   ```c++
   ListNode* dummyHead = new ListNode(-1);
   ```

2. 合理构造循环指针，比如快慢指针(fast, slow)，"前"指针(prev)...并且初值赋设置为dummyHead

   ```c++
   ListNode* prev = dummyHead;
   ```

3. 结合题意合理构造循环终止条件

   ```c++
   while(prev != null){}
   
   while(prev != null && prev->next !+ null){}
   
   ......
   ```

**针对快慢节点，链表中常见的是fast和slow，即fast跳2步，slow跳1步。所导致的结果是fast走到了链表末尾，slow则走到了中间。这种快慢节点针对的是那些涉及到平分链表的题目，如**

1. [Leetcode234-回文链表](./Leetcode234-回文链表.md)
2. 

**平分链表有一个分类讨论的问题，就是链表节点数是奇数还是偶数。当节点个数为奇数时在遍历的时候slow节点需要跳过中间节点，slow节点是否需要在循环结束之后再继续往后移动一个单位需要具体问题具体分析，但是究其本质：<u>节点数为奇数时，slow最后在最中间；节点数为偶数时，slow最后在后半部分的第一个</u>**，以Leetcode234为例子来分析，因为我要判断一个链表是否是回文链表，跟节点数为奇数时最中间的节点无关，我要定位的还是前半部分和后半部分，所以需要让slow向后移动一个单位。

```c++
// 快慢链表标准模板
ListNode *fast = head, *slow = head;

while(fast && fast->next){
  slow = slow->next;    //快慢遍历
  fast = fast->next->next;
}
if(fast)  //奇数个节点时跳过中间节点
  slow = slow->next;

// head, fast, slow的初始位置都为第一个节点
// 例：链表元素为1->2->3->4->5, 当停止循环时slow位于3，需要把slow定位到后半部分

// 例：链表元素为1->2->3->4, 当停止循环时slow位于3，刚好位于后半部分的第一个节点
```

**注：不管节点个数为奇数还是偶数，当循环最后一次执行最开始，slow节点是前半部分的最后一个节点。这个性质能做出很多花样**

```c++
while(fast && fast->next){
  // 如果这里用节点p去保存slow的值的话，那么p就是前半部分的最后一个节点
  // 链表元素为1->2->3->4->5, 执行最后一次循环并且执行该行代码后，p的值为2，即离开循环体后p的值还是为2
  // 链表元素为1->2->3->4, 执行最后一次循环并且执行该行代码后，p的值为2，即离开循环体后p的值还是为2
  ListNode *p = slow;
  
  slow = slow->next;    //快慢遍历
  fast = fast->next->next;
}
```

