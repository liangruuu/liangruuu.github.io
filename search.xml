<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>article2</title>
      <link href="post/be06406e.html"/>
      <url>post/be06406e.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-dasdas"><a href="#1-dasdas" class="headerlink" title="1. dasdas"></a>1. dasdas</h3><h4 id="2-adasd"><a href="#2-adasd" class="headerlink" title="2. adasd"></a>2. adasd</h4><ul><li>dsadas<ul><li>dsadas</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="post/4a17b156.html"/>
      <url>post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>/_ primary _/</p><div  class="note icon custom iconfont icon-QQ2"  style="background: #f5f0fa;border-left-color: #6f42c1;">  <p>primary</p></div><blockquote><p>content</p><footer><strong>[author[</strong><cite>source]] [link] [source_link_title]</cite></footer></blockquote><div class="gallery-group-main">    <figure class="gallery-group">  <img class="gallery-group-img" src= "/img/loading.gif" data-lazy-src='https://i.loli.net/2019/11/10/T7Mu8Aod3egmC4Q.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">壁纸</div>  <p>收藏的一些壁纸</p>  <a href='/Gallery/wallpaper'></a>  </figcaption>  </figure>     <figure class="gallery-group">  <img class="gallery-group-img" src= "/img/loading.gif" data-lazy-src='https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">漫威</div>  <p>关于漫威的图片</p>  <a href='/Gallery/marvel'></a>  </figcaption>  </figure>     <figure class="gallery-group">  <img class="gallery-group-img" src= "/img/loading.gif" data-lazy-src='https://i.loli.net/2019/12/25/hOqbQ3BIwa6KWpo.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">OH MY  GIRL</div>  <p>关于OH MY GIRL的图片</p>  <a href='/Gallery/ohmygirl'></a>  </figcaption>  </figure>  </div><div class="note info modern"><p>info 提示块标签</p></div><div class="checkbox yellow checked">  <input type="checkbox" checked />  <p>黄色 + 默认选中</p></div>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode404. 左叶子之和</title>
      <link href="post/23310d0f.html"/>
      <url>post/23310d0f.html</url>
      
        <content type="html"><![CDATA[<p><a href="./%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E5%92%8C%E9%80%92%E5%BD%92%E7%9A%84%E5%8C%BA%E5%88%AB.md">DFS模板参考</a></p><a id="more"></a><p>本题需要计算二叉树所有左叶子之和，只需在遍历的过程中判断是否到达了左叶子，在这里到达左叶子的判断标准为：</p><ol><li>是否是当前节点的左孩子</li><li>当前节点的左孩子是不是叶子节点（叶子结点：没有左右孩子）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;left-&gt;right==<span class="literal">NULL</span>)ans+=root-&gt;left-&gt;val;</span><br><span class="line">            <span class="keyword">else</span> ans+=sumOfLeftLeaves(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            ans+=sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode257. 二叉树的所有路径</title>
      <link href="post/148a306b.html"/>
      <url>post/148a306b.html</url>
      
        <content type="html"><![CDATA[<p><strong>按照DFS模板分析</strong></p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, <span class="string">&quot;&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, String path, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果为空，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (root == null)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果是叶子节点，说明找到了一条路径，把它加入到res中</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">            res.add(path + root.val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不是叶子节点，在分别遍历他的左右子节点</span></span><br><span class="line">        dfs(root.left, path + root.val + <span class="string">&quot;-&gt;&quot;</span>, res);</span><br><span class="line">        dfs(root.right, path + root.val + <span class="string">&quot;-&gt;&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode235. 二叉搜索树的最近公共祖先</title>
      <link href="post/d778fc0e.html"/>
      <url>post/d778fc0e.html</url>
      
        <content type="html"><![CDATA[<p><strong>按照DFS模板分析</strong></p><a id="more"></a><p>本题需要利用好<strong>二分搜索树</strong>的性质，即左子树值小于根节点，右子树值大于根节点；与之对应的<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a>则没有二分搜索树的性质</p><p>从根节点开始遍历树</p><ol><li>如果节点 pp 和节点 qq 都在右子树上，那么以右孩子为根节点继续 1 的操作</li><li>如果节点 pp 和节点 qq 都在左子树上，那么以左孩子为根节点继续 1 的操作</li><li>如果条件 2 和条件 3 都不成立，这就意味着我们已经找到节 pp 和节点 qq 的 LCA 了</li></ol><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/57065f75de837616260b54bac172ef9b3c1afab04468ef2ea3394a6708949fa7-image.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> parentVal = root.val;</span><br><span class="line">        <span class="keyword">int</span> pVal = p.val;</span><br><span class="line">        <span class="keyword">int</span> qVal = q.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pVal &gt; parentVal &amp;&amp; qVal &gt; parentVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pVal &lt; parentVal &amp;&amp; qVal &lt; parentVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里顺便解决一下</strong><code>236. 二叉树的最近公共祖先</code>，原理和Leetcode235基本一致，只不过没有二叉搜索树这个性质，需要判断左右子树是否为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode226. 翻转二叉树</title>
      <link href="post/62dc7c8b.html"/>
      <url>post/62dc7c8b.html</url>
      
        <content type="html"><![CDATA[<p><strong>典型的DFS和BFS都能做的题目</strong></p><p><a href="./%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E5%92%8C%E9%80%92%E5%BD%92%E7%9A%84%E5%8C%BA%E5%88%AB.md">DFS模板参考</a>和<a href="./BFS%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF.md">BFS模板参考</a></p><a id="more"></a><h4 id="方法一：DFS"><a href="#方法一：DFS" class="headerlink" title="方法一：DFS"></a>方法一：DFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode right = invertTree(root.right);</span><br><span class="line">    TreeNode left = invertTree(root.left);</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二：BFS"><a href="#方法二：BFS" class="headerlink" title="方法二：BFS"></a>方法二：BFS</h4><p><strong>翻转二叉树是从上到下，从左到右的翻转，这就是层序遍历的流程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode current = queue.poll();</span><br><span class="line">        TreeNode temp = current.left;</span><br><span class="line">        current.left = current.right;</span><br><span class="line">        current.right = temp;</span><br><span class="line">        <span class="keyword">if</span> (current.left != <span class="keyword">null</span>) queue.add(current.left);</span><br><span class="line">        <span class="keyword">if</span> (current.right != <span class="keyword">null</span>) queue.add(current.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> 树 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode103. 二叉树的锯齿形层次遍历</title>
      <link href="post/1e4fa564.html"/>
      <url>post/1e4fa564.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/solution/jiao-ti-shi-yong-zhan-jian-dan-shi-xian-ju-chi-xin/">Leetcode题解（One Piece），略有增删</a></strong></p><a id="more"></a><p>思路：</p><ol><li>层序遍历节点的顺序是都从左到右，但是本题的”之字形遍历”会导致偶数层的遍历顺序是从右到左，即<strong>逆序遍历</strong>。这正好满足栈思想，所有用栈来第二层所有节点。</li><li>遍历栈输出第二层节点，同时还需要将第三层的节点按照从右到左的顺序存储。但是不能将第三层的节点存储到这个栈中，因为会打乱第二层节点的顺序，此时我们可以想到创建另一个栈来存储第三层的元素。这样层与层之间就不会产生干扰。</li><li>交替使用这两个栈遍历所有的层。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//栈1来存储右节点到左节点的顺序</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;(); </span><br><span class="line">    <span class="comment">//栈2来存储左节点到右节点的顺序</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根节点入栈</span></span><br><span class="line">    stack1.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次循环中，都是一个栈为空，一个栈不为空，结束的条件两个都为空</span></span><br><span class="line">    <span class="keyword">while</span> (!stack1.isEmpty() || !stack2.isEmpty()) &#123;</span><br><span class="line">      List&lt;Integer&gt; subList = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 存储这一个层的数据</span></span><br><span class="line">      TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!stack1.isEmpty()) &#123; <span class="comment">//栈1不为空，则栈2此时为空，需要用栈2来存储从下一层从左到右的顺序</span></span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty()) &#123;<span class="comment">//遍历栈1中所有元素，即当前层的所有元素</span></span><br><span class="line">          cur = stack1.pop();</span><br><span class="line">          subList.add(cur.val);<span class="comment">//存储当前层所有元素</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;<span class="comment">//左节点不为空加入下一层</span></span><br><span class="line">            stack2.push(cur.left);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;<span class="comment">//右节点不为空加入下一层</span></span><br><span class="line">            stack2.push(cur.right);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(subList);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//栈2不为空，则栈1此时为空，需要用栈1来存储从下一层从右到左的顺序</span></span><br><span class="line">        <span class="keyword">while</span> (!stack2.isEmpty()) &#123;</span><br><span class="line">          cur = stack2.pop();</span><br><span class="line">          subList.add(cur.val);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;<span class="comment">//右节点不为空加入下一层</span></span><br><span class="line">            stack1.push(cur.right);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123; <span class="comment">//左节点不为空加入下一层</span></span><br><span class="line">            stack1.push(cur.left);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(subList);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode95. 不同的二叉搜索树 II</title>
      <link href="post/3b6ad9e9.html"/>
      <url>post/3b6ad9e9.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/solution/bu-tong-de-er-cha-sou-suo-shu-ii-by-leetcode-solut/">Leetcode题解（力扣官方题解），略有增删</a></strong></p><a id="more"></a><h4 id="一、递归"><a href="#一、递归" class="headerlink" title="一、递归"></a>一、递归</h4><p><strong>递归解法详见：<a href="./%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E5%92%8C%E9%80%92%E5%BD%92%E7%9A%84%E5%8C%BA%E5%88%AB.md">分而治之和递归的区别</a></strong></p><p>所以如果求 1…n 的所有可能。</p><p>我们只需要把 1 作为根节点，[ ] 空作为左子树，[ 2 … n ] 的所有可能作为右子树。</p><p>2 作为根节点，[ 1 ] 作为左子树，[ 3…n ] 的所有可能作为右子树。</p><p>3 作为根节点，[ 1 2 ] 的所有可能作为左子树，[ 4 … n ] 的所有可能作为右子树，然后左子树和右子树两两组合。</p><p>4 作为根节点，[ 1 2 3 ] 的所有可能作为左子树，[ 5 … n ] 的所有可能作为右子树，然后左子树和右子树两两组合。</p><p>…</p><p>n 作为根节点，[ 1… n ] 的所有可能作为左子树，[ ] 作为右子树。</p><p>至于，[ 2 … n ] 的所有可能以及 [ 4 … n ] 以及其他情况的所有可能，可以利用上边的方法，把每个数字作为根节点，然后把所有可能的左子树和右子树组合起来即可。</p><p>如果只有一个数字，那么所有可能就是一种情况，把该数字作为一棵树。而如果是 [ ]，那就返回 null。</p><hr><ol><li><p>状态：数组下标(变化量)，用i表示；<code>recursion(i)</code>表示以i为根节点构造符合条件的树，<strong>而它返回的应该是一个树节点数组</strong>。根据上面的分析，这个i是通过循环遍历整个序列所得，而序列是由左右边界的，即用(start, end)表示，同时把递归函数参数修改成<code>recursion(start, end)</code></p></li><li><p>递归终止条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果用strat和end来限制边界的话，那么结束递归的条件就是start &gt; end</span></span><br><span class="line"><span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">  allTrees.add(<span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">return</span> allTrees;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>状态转移方程(可能涉及到多次if条件判断)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举可行根节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">  <span class="comment">// 获得所有可行的左子树集合</span></span><br><span class="line">  List&lt;TreeNode&gt; leftTrees = generateTrees(start, i - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获得所有可行的右子树集合</span></span><br><span class="line">  List&lt;TreeNode&gt; rightTrees = generateTrees(i + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span></span><br><span class="line">  <span class="keyword">for</span> (TreeNode left : leftTrees) &#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode right : rightTrees) &#123;</span><br><span class="line">      TreeNode currTree = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">      currTree.left = left;</span><br><span class="line">      currTree.right = right;</span><br><span class="line">      allTrees.add(currTree);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回最终状态：return recursion(1， n)；</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; allTrees = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            allTrees.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> allTrees;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举可行根节点，这里采用循环是因为本题题意的特殊性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="comment">// 获得所有可行的左子树集合</span></span><br><span class="line">            List&lt;TreeNode&gt; leftTrees = generateTrees(start, i - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获得所有可行的右子树集合</span></span><br><span class="line">            List&lt;TreeNode&gt; rightTrees = generateTrees(i + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode left : leftTrees) &#123;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode right : rightTrees) &#123;</span><br><span class="line">                    TreeNode currTree = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    currTree.left = left;</span><br><span class="line">                    currTree.right = right;</span><br><span class="line">                    allTrees.add(currTree);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode445. 两数相加 II</title>
      <link href="post/49af10aa.html"/>
      <url>post/49af10aa.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/add-two-numbers-ii/solution/javakai-fa-by-sweetiee/">Leetcode题解（Sweetiee），略有增删</a></strong></p><p><a href="./%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF.md">请结合该文处理链表题目的方法分析链表解题思路</a>，逆序处理，似乎一般都会用到栈，一个小tips</p><a id="more"></a><p>用 stack 保存链表，再从 stack 中取出来，就是数字从低位到高位访问了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123; </span><br><span class="line">        Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack1.push(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack2.push(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty() || !stack2.isEmpty() || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = carry;</span><br><span class="line">            sum += stack1.isEmpty()? <span class="number">0</span>: stack1.pop();</span><br><span class="line">            sum += stack2.isEmpty()? <span class="number">0</span>: stack2.pop();</span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            node.next = dummyHead.next;</span><br><span class="line">            dummyHead.next = node;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode143. 重排链表</title>
      <link href="post/dad28f1c.html"/>
      <url>post/dad28f1c.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/reorder-list/solution/2019tong-kao-408zhen-ti-jiao-ke-shu-shi-da-an-by-m/">Leetcode题解（用力 扣不动），略有增删</a></strong></p><p><a href="./%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF.md">请结合该文处理链表题目的方法分析链表解题思路</a>，<strong>此题是快慢指针题的一种，即使用快慢指针平分链表</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* p=head,*q=head,*r,*s=head;</span><br><span class="line">        <span class="keyword">if</span>(!head)            <span class="comment">//head为空，则直接退出</span></span><br><span class="line">            <span class="keyword">return</span> ;         </span><br><span class="line">        <span class="keyword">while</span>(q-&gt;next)&#123;      <span class="comment">//寻找中间结点</span></span><br><span class="line">            q=q-&gt;next;       <span class="comment">//p走一步</span></span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;next)</span><br><span class="line">              q=q-&gt;next;     <span class="comment">//q走两步</span></span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 根据链表模板里的说法我只需要后半部分的第一个节点</span></span><br><span class="line">      <span class="comment">// 并且循环结束后，若链表节点个数为奇数，则slow为前后半之间的那个中间元素，若个数时偶数，则slow为前半部分最后一个节点</span></span><br><span class="line">        q=p-&gt;next;           <span class="comment">//p所指结点为中间结点，q为后半段链表的首结点</span></span><br><span class="line">        p-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(q)&#123;            <span class="comment">//将链表后半段逆置</span></span><br><span class="line">            r=q-&gt;next;</span><br><span class="line">            q-&gt;next=p-&gt;next;</span><br><span class="line">            p-&gt;next=q;</span><br><span class="line">            q=r;</span><br><span class="line">        &#125;</span><br><span class="line">        q=p-&gt;next;            <span class="comment">//q指向后半段的第一个数据结点</span></span><br><span class="line">        p-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(q)&#123;             <span class="comment">//将链表后半段的结点插入到指定位置</span></span><br><span class="line">            r=q-&gt;next;        <span class="comment">//r指向后半段的下一个结点</span></span><br><span class="line">            q-&gt;next=s-&gt;next;  <span class="comment">//将q所指结点插入到s所指结点（head结点）之后</span></span><br><span class="line">            s-&gt;next=q;        </span><br><span class="line">            s=q-&gt;next;        <span class="comment">//s指向前半段的下一个插入点</span></span><br><span class="line">            q=r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode234. 回文链表</title>
      <link href="post/18779b66.html"/>
      <url>post/18779b66.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-1zhan-2kuai-man-zhi-zhen-fan-zhu/">Leetcode题解（hello_pretty），略有增删</a></strong></p><p><a href="./%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF.md">请结合该文处理链表题目的方法分析链表解题思路</a>，<strong>此题是快慢指针题的一种，即使用快慢指针平分链表</strong></p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        ListNode *p, *pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            p = slow;</span><br><span class="line">            slow = slow-&gt;next;    <span class="comment">//快慢遍历</span></span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            p-&gt;next = pre;  <span class="comment">//翻转</span></span><br><span class="line">            pre = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast)  <span class="comment">//奇数个节点时跳过中间节点</span></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p)&#123;       <span class="comment">//前半部分和后半部分比较</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val != slow-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode82. 删除排序链表中的重复元素 II</title>
      <link href="post/49aa0bfb.html"/>
      <url>post/49aa0bfb.html</url>
      
        <content type="html"><![CDATA[<p>**转载自：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/solution/java-ya-jie-dian-fei-di-gui-rong-yi-li-jie-yong-sh/">Leetcode题解（keithy），略有增删</a>**，请结合该文处理链表题目的<a href="./%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF.md">方法分析链表解题思路</a></p><a id="more"></a><ol><li>与链表的其他题目类似，为了防止删除头结点的极端情况发生，先创建空结点dummy，使dummy指向传入的head结点。然后创建cur的指针，指向链表的头部(即dummy)，这都是模板里提供的方法。</li><li>为了删除值相同的节点，需要在遍历链表的循环里再嵌套一层循环</li><li>注意循环条件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next.val == cur.next.next.val) &#123;</span><br><span class="line">                ListNode temp = cur.next;</span><br><span class="line">                <span class="keyword">while</span> (temp != <span class="keyword">null</span> &amp;&amp; temp.next != <span class="keyword">null</span> &amp;&amp; temp.val == temp.next.val ) &#123;</span><br><span class="line">                    temp = temp.next;</span><br><span class="line">                &#125;</span><br><span class="line">                cur.next = temp.next;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 快慢指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode61. 旋转链表</title>
      <link href="post/a76f31bc.html"/>
      <url>post/a76f31bc.html</url>
      
        <content type="html"><![CDATA[<p><strong>一般旋转指针的题目都是使用数字取余的方式做的，但是使用快慢指针方法更加直观。以后做链表的题目多想想能不能用快慢指针的方法做</strong></p><p>**转载自：<a href="https://leetcode-cn.com/problems/rotate-list/solution/dong-tu-suan-fa-xuan-zhuan-lian-biao-si-chong-ji-3/">Leetcode题解（一个歪卜），略有增删</a>**，请结合该文处理链表题目的<a href="./%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF.md">方法分析链表解题思路</a></p><a id="more"></a><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/bbaf1c2d256eb2641fac9c637e169b60b9dc83655e8a0605527aba7e249b68b2-file_1597038479849.gif" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fast = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// slow == fast说明k会被链表长度整除，故无需操作head直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对慢指针位置进行打断</span></span><br><span class="line">        fast-&gt;next = head;</span><br><span class="line">        head = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 快慢指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode24. 两两交换链表中的节点</title>
      <link href="post/5cec6287.html"/>
      <url>post/5cec6287.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-19/">Leetcode题解（力扣官方题解），略有增删</a></strong></p><p><a href="./%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF.md">请结合该文处理链表题目的方法分析链表解题思路</a></p><a id="more"></a><h4 id="一、递归"><a href="#一、递归" class="headerlink" title="一、递归"></a>一、递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((head == <span class="keyword">null</span>) || (head.next == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Nodes to be swapped</span></span><br><span class="line">        ListNode firstNode = head;</span><br><span class="line">        ListNode secondNode = head.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Swapping</span></span><br><span class="line">        firstNode.next  = swapPairs(secondNode.next);</span><br><span class="line">        secondNode.next = firstNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now the head is the second node</span></span><br><span class="line">        <span class="keyword">return</span> secondNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、迭代"><a href="#二、迭代" class="headerlink" title="二、迭代"></a>二、迭代</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dummy node acts as the prevNode for the head node</span></span><br><span class="line">        <span class="comment">// of the list and hence stores pointer to the head node.</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode prevNode = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((head != <span class="keyword">null</span>) &amp;&amp; (head.next != <span class="keyword">null</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Nodes to be swapped</span></span><br><span class="line">            ListNode firstNode = head;</span><br><span class="line">            ListNode secondNode = head.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Swapping</span></span><br><span class="line">            prevNode.next = secondNode;</span><br><span class="line">            firstNode.next = secondNode.next;</span><br><span class="line">            secondNode.next = firstNode;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reinitializing the head and prevNode for next swap</span></span><br><span class="line">            prevNode = firstNode;</span><br><span class="line">            head = firstNode.next; <span class="comment">// jump</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the new head node.</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode23. 合并K个升序链表</title>
      <link href="post/f6c5761a.html"/>
      <url>post/f6c5761a.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/he-bing-kge-pai-xu-lian-biao-by-leetcode-solutio-2/">Leetcode题解（力扣官方题解），略有增删</a></strong></p><p><a href="./%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF.md">请结合该文处理链表题目的方法分析链表解题思路</a>，<strong>该题也是<a href="./Leetcode21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.md">合并两个有序链表</a>的拓展</strong></p><a id="more"></a><h4 id="一、顺序合并"><a href="#一、顺序合并" class="headerlink" title="一、顺序合并"></a>一、顺序合并</h4><p>先考虑合并三个有序链表，假设有这样的三个链表[L1, L2, L3]，如果以合并两个有序链表为原始问题的话，那么先把前两个链表两两合并生成L12，再把生成的新链表和L3链表合并生成L123。发现规律了吗？<strong>其实合并K个链表就是进行K - 1次两两合并</strong>，那么我么只需要对原始链表数组进行遍历合并即可，两两合并操作参考<a href="./Leetcode21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.md">合并两个有序链表</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        ListNode* prev = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                prev-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev-&gt;next = l1 == <span class="literal">nullptr</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode *ans = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; lists.size(); ++i) &#123;</span><br><span class="line">            ans = mergeTwoLists(ans, lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="二、分治合并"><a href="#二、分治合并" class="headerlink" title="二、分治合并"></a>二、分治合并</h4><p>连续进行K - 1次两两合并很容易能联想到<strong>分治算法</strong></p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/6f70a6649d2192cf32af68500915d84b476aa34ec899f98766c038fc9cc54662-image.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        ListNode* prev = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                prev-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev-&gt;next = l1 == <span class="literal">nullptr</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(<span class="built_in">vector</span> &lt;ListNode*&gt; &amp;lists, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> lists[l];</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表解题思路</title>
      <link href="post/fe00eebf.html"/>
      <url>post/fe00eebf.html</url>
      
        <content type="html"><![CDATA[<p><strong>跟链表相关的题目一般需要注意以下几点</strong></p><a id="more"></a><ol><li><p>当使用<strong>迭代法</strong>处理链表题时，在函数体最开始规定先构造虚拟头结点(dummyHead)；特别的，当时用<strong>递归法</strong>处理链表问题时不需要考虑构造虚拟头结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListNode* dummyHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure></li><li><p>合理构造循环指针，比如快慢指针(fast, slow)，”前”指针(prev)…并且初值赋设置为dummyHead</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListNode* prev = dummyHead;</span><br></pre></td></tr></table></figure></li><li><p>结合题意合理构造循环终止条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(prev != null)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(prev != null &amp;&amp; prev-&gt;next !+ null)&#123;&#125;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure></li></ol><p><strong>针对快慢节点，链表中常见的是fast和slow，即fast跳2步，slow跳1步。所导致的结果是fast走到了链表末尾，slow则走到了中间。这种快慢节点针对的是那些涉及到平分链表的题目，如</strong></p><ol><li><a href="./Leetcode234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8.md">Leetcode234-回文链表</a></li><li></li></ol><p>**平分链表有一个分类讨论的问题，就是链表节点数是奇数还是偶数。当节点个数为奇数时在遍历的时候slow节点需要跳过中间节点，slow节点是否需要在循环结束之后再继续往后移动一个单位需要具体问题具体分析，但是究其本质：<u>节点数为奇数时，slow最后在最中间；节点数为偶数时，slow最后在后半部分的第一个</u>**，以Leetcode234为例子来分析，因为我要判断一个链表是否是回文链表，跟节点数为奇数时最中间的节点无关，我要定位的还是前半部分和后半部分，所以需要让slow向后移动一个单位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快慢链表标准模板</span></span><br><span class="line">ListNode *fast = head, *slow = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">  slow = slow-&gt;next;    <span class="comment">//快慢遍历</span></span><br><span class="line">  fast = fast-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(fast)  <span class="comment">//奇数个节点时跳过中间节点</span></span><br><span class="line">  slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">// head, fast, slow的初始位置都为第一个节点</span></span><br><span class="line"><span class="comment">// 例：链表元素为1-&gt;2-&gt;3-&gt;4-&gt;5, 当停止循环时slow位于3，需要把slow定位到后半部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例：链表元素为1-&gt;2-&gt;3-&gt;4, 当停止循环时slow位于3，刚好位于后半部分的第一个节点</span></span><br></pre></td></tr></table></figure><p><strong>注：不管节点个数为奇数还是偶数，当循环最后一次执行最开始，slow节点是前半部分的最后一个节点。这个性质能做出很多花样</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">  <span class="comment">// 如果这里用节点p去保存slow的值的话，那么p就是前半部分的最后一个节点</span></span><br><span class="line">  <span class="comment">// 链表元素为1-&gt;2-&gt;3-&gt;4-&gt;5, 执行最后一次循环并且执行该行代码后，p的值为2，即离开循环体后p的值还是为2</span></span><br><span class="line">  <span class="comment">// 链表元素为1-&gt;2-&gt;3-&gt;4, 执行最后一次循环并且执行该行代码后，p的值为2，即离开循环体后p的值还是为2</span></span><br><span class="line">  ListNode *p = slow;</span><br><span class="line">  </span><br><span class="line">  slow = slow-&gt;next;    <span class="comment">//快慢遍历</span></span><br><span class="line">  fast = fast-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode21. 合并两个有序链表</title>
      <link href="post/f818133b.html"/>
      <url>post/f818133b.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/">Leetcode题解（力扣官方题解），略有增删</a></strong></p><p><a href="./%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF.md">请结合该文处理链表题目的方法分析链表解题思路</a>，<strong>该题也是合并K个有序链表的题根</strong></p><a id="more"></a><h4 id="一、递归"><a href="#一、递归" class="headerlink" title="一、递归"></a>一、递归</h4><p>如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。</p><ol><li><p>状态：两个原始列表的节点，用l1和l2表示，recursion(l1, l2)表示两个链表前l1和l2个元素能够组成的递增链表</p></li><li><p>递归终止条件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> l2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> l1;</span><br></pre></td></tr></table></figure></li><li><p>状态转移方程(可能涉及到多次if条件判断)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">  l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">  <span class="keyword">return</span> l1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">  <span class="keyword">return</span> l2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回最终状态：return recursion(l1, l2)；</p></li></ol><p><strong>完整代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="二、迭代"><a href="#二、迭代" class="headerlink" title="二、迭代"></a>二、迭代</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        ListNode* prev = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                prev-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev-&gt;next = l1 == <span class="literal">nullptr</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法与数据结构优秀博客网站</title>
      <link href="post/e27c4f06.html"/>
      <url>post/e27c4f06.html</url>
      
        <content type="html"><![CDATA[<p>本页主要汇总各个优秀博客以及网站链接</p><a id="more"></a><ul><li><a href="https://www.cnblogs.com/skywang12345/">skywang12345</a>：数据结构和算法的详细介绍(图片+文字详细说明)，<a href="https://github.com/wangkuiwu/datastructs_and_algorithm">源码</a></li><li><a href="https://www.cnblogs.com/liuzhen1995/">舞动的心</a>：<a href="https://www.cnblogs.com/liuzhen1995/p/11789339.html">LeetCode刷题总结-数组篇（上）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优秀博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆相关算法</title>
      <link href="post/81abcd2b.html"/>
      <url>post/81abcd2b.html</url>
      
        <content type="html"><![CDATA[<p><strong>堆Heap，俗称优先队列priority queue。在做题时绝大部分都是用来求一串序列中的最大最小值的</strong></p><h4 id="一、堆的基础表示"><a href="#一、堆的基础表示" class="headerlink" title="一、堆的基础表示"></a>一、堆的基础表示</h4><ol><li><strong>一个堆就是一棵树用数组表示的完全二叉树</strong></li><li><strong>堆中某个节点的值总是不大于(小于)其父节点的值，对应叫法为大根堆，小根堆</strong></li></ol><p>用数组存放堆，每个堆元素对应的数组下标为，下面一幅图是以初始元素的下标为0制定的</p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598598625641.png" alt="1598598625641"></p><h4 id="二、向堆中添加元素和Sift-Up"><a href="#二、向堆中添加元素和Sift-Up" class="headerlink" title="二、向堆中添加元素和Sift Up"></a>二、向堆中添加元素和Sift Up</h4><p>我们向二叉堆添加一个元素，对于用数组构建的堆来说，就相当于在数组末尾添加一个元素</p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598598781224.png" alt="1598598781224"></p><hr><p><img src= "/img/loading.gif" data-lazy-src="./%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598598827464.png" alt="1598598827464"></p><hr><p>若二叉堆为大根堆时，当添加进一个元素之后，若新增元素比它父亲节点要大，则打破了大根堆的性质，所以要对其重新<strong>大根堆化</strong>，即交换父亲和孩子节点值。在数组中的体现就是原来下标的数值交换，并且把当前要处理的堆节点变为父节点</p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598598921197.png" alt="1598598921197"></p><p>同理不断地对堆元素进行Sift Up，直到当前处理元素下标为0或者父亲节点值大于孩子结点值</p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598599316554.png" alt="1598599316554"></p><hr><p><img src= "/img/loading.gif" data-lazy-src="./%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598599388760.png" alt="1598599388760"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示对堆里的第几个元素进行siftUp操作</span></span><br><span class="line"><span class="comment">// 调用格式：siftUp(data.size() - 1); 即对堆的最后一个元素进行siftUp操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 当前节点下标&gt;0 且 父亲节点值大于当前节点值</span></span><br><span class="line"><span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; data[parent(k)] &lt; data[k])&#123;</span><br><span class="line">    swap(k, parent(k));</span><br><span class="line">    k = parent(k);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> data[(k - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  t = data[i];</span><br><span class="line">  data[i] = data[j];</span><br><span class="line">  data[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、取出堆中的最大元素和Sift-Down"><a href="#三、取出堆中的最大元素和Sift-Down" class="headerlink" title="三、取出堆中的最大元素和Sift Down"></a>三、取出堆中的最大元素和Sift Down</h4><p>我们之所以称一个堆为最大堆，是因为我们取出操作只能取堆顶的元素，也就是大根堆里最大的元素，不能取出其他元素。</p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598600079760.png" alt="1598600079760"></p><hr><p>我们取出堆顶元素，就是把堆顶元素删除然后把堆末尾元素放到堆顶</p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598600190867.png" alt="1598600190867"></p><p>同时把最后一个元素删除掉，那么首先从元素个数来看，我们成功减少了一个元素，并且我们真正减少的就是原来二叉堆堆顶的那个元素。但是此时堆顶的元素打破了原来大根堆的性质，所以我们需要把堆顶元素往下调整</p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598600296055.png" alt="1598600296055"></p><p>选择当前节点孩子节点中值最大的那个元素节点，如果孩子节点的最大值要比当前节点值还要大的话就把两者交换位置</p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598600373041.png" alt="1598600373041"></p><hr><p><img src= "/img/loading.gif" data-lazy-src="./%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598600419887.png" alt="1598600419887"></p><p>同理沿着节点一直交换下去</p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598600460251.png" alt="1598600460251"></p><hr><p>直到当前节点值大于左右孩子节点值或者为叶子结点</p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598600489788.png" alt="1598600489788"></p><hr><p><img src= "/img/loading.gif" data-lazy-src="./%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598600590025.png" alt="1598600590025"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取出堆顶元素，并且保持大/小根堆的性质</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> max = data[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  swap(<span class="number">0</span>, data.size() - <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// len 值数组长度</span></span><br><span class="line">  len = data.size() - <span class="number">1</span>;</span><br><span class="line">  siftDown(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  t = data[i];</span><br><span class="line">  data[i] = data[j];</span><br><span class="line">  data[j] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示对堆里的第几个元素进行siftDown操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 左孩子节点下标不能大于数组长度</span></span><br><span class="line">  <span class="keyword">while</span>(leftChild(k) &lt; data.size())&#123;</span><br><span class="line">    <span class="keyword">int</span> j = leftChild(k);</span><br><span class="line">    <span class="comment">// 要么是左孩子最大，要么是右孩子最大，选一个跟当前节点交换位置</span></span><br><span class="line">    <span class="keyword">if</span>(j + <span class="number">1</span> &lt; data.size() &amp;&amp; data[j + <span class="number">1</span>] &gt; data[j])&#123;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(data[k] &gt;= data[j])&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(k, j);</span><br><span class="line">    <span class="comment">// 不断下沉</span></span><br><span class="line">    k = j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * k + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、Heapify-将数任意数组整理成堆的形状"><a href="#四、Heapify-将数任意数组整理成堆的形状" class="headerlink" title="四、Heapify(将数任意数组整理成堆的形状)"></a>四、Heapify(将数任意数组整理成堆的形状)</h4><p><strong>使用之前的Sift Down和Sift Up操作</strong></p><p>一个任意的数组用二叉堆的形式表示：元素组为[15, 17, 19, 13, 22, 16, 28, 30, 41, 62]，但是它不符合大根堆或者小根堆的性质</p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598601117916.png" alt="1598601117916"></p><p><strong>从最后一个非叶子结点开始计算</strong>，不断从右到左，从下到上的进行Sift Down操作即可，<strong>最后一个非叶子结点对应数组下标为最后一个节点的父节点的下标</strong></p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598601216156.png" alt="1598601216156"></p><hr><p><img src= "/img/loading.gif" data-lazy-src="./%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598601309254.png" alt="1598601309254"></p><p>同理</p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598601334083.png" alt="1598601334083"></p><hr><p><img src= "/img/loading.gif" data-lazy-src="./%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598601346054.png" alt="1598601346054"></p><hr><p><img src= "/img/loading.gif" data-lazy-src="./%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598601377917.png" alt="1598601377917"></p><hr><p><img src= "/img/loading.gif" data-lazy-src="./%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598601398430.png" alt="1598601398430"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = parent(data.size() - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">    siftDown(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (k - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode210. 课程表 II</title>
      <link href="post/a7af824c.html"/>
      <url>post/a7af824c.html</url>
      
        <content type="html"><![CDATA[<p><strong>详情参考<a href="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95.md">图相关算法</a></strong></p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图相关算法</title>
      <link href="post/383f8c30.html"/>
      <url>post/383f8c30.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://blog.csdn.net/wangdy0707/article/details/103241915">CSDN（老阳07），略有增删</a></strong></p><a id="more"></a><h4 id="〇、初始化图"><a href="#〇、初始化图" class="headerlink" title="〇、初始化图"></a>〇、初始化图</h4><p><strong>虽然图算法重要，但是对图的构造也是成功的第一步，在Leetcode刷题的时候一般需要对已知条件通过邻接表或者邻接矩阵的形式构造图，然后才在此基础上进行各式各样的算法。这里先介绍几种类型的构造方式，以后做跟图相关的题目时直接照抄即可</strong></p><ol><li><p><strong>无向无权图</strong>的<strong>邻接表</strong>构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给出条件    输入：edges = [ [1,2], [2,3], [3,4], [1, 3] ], V = 4, E = 4</span></span><br><span class="line">Map&lt;Integer, LinkedList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] edge : edges)&#123;</span><br><span class="line">  <span class="keyword">if</span> (!graph.containsKey(edge[<span class="number">0</span>]))&#123;</span><br><span class="line">    graph.put(edge[<span class="number">0</span>], <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!graph.containsKey(edge[<span class="number">1</span>]))&#123;</span><br><span class="line">    graph.put(edge[<span class="number">1</span>], <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">  &#125;</span><br><span class="line">  graph.get(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);</span><br><span class="line">  graph.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>无向无权图</strong>的<strong>邻接矩阵</strong>构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给出条件    输入：edges = [ [1,2], [2,3], [3,4], [1, 3] ], V = 4, E = 4</span></span><br><span class="line"><span class="keyword">int</span>[][] graph = <span class="keyword">new</span> <span class="keyword">int</span>[V][V];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] edge : edges)&#123;</span><br><span class="line">  graph[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">  graph[edge[<span class="number">1</span>]][edge[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="一、广度优先搜索（BFS）"><a href="#一、广度优先搜索（BFS）" class="headerlink" title="一、广度优先搜索（BFS）"></a>一、广度优先搜索（BFS）</h4><p><a href="./BFS%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF.md">BFS问题模板</a></p><h4 id="二、深度优先搜索（DFS）"><a href="#二、深度优先搜索（DFS）" class="headerlink" title="二、深度优先搜索（DFS）"></a>二、深度优先搜索（DFS）</h4><p><a href="./%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E5%92%8C%E9%80%92%E5%BD%92%E7%9A%84%E5%8C%BA%E5%88%AB.md">分而治之和递归的区别</a></p><p><strong>图和一般二维数组的DFS在形式是有些许不同，沿用〇、1. 无向无权图的邻接表构造</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> main <span class="title">void</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 新建图结构.....</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">  ArrayList&lt;Integer&gt; order = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  dfs(<span class="string">&quot;key值&quot;</span>, visited, order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">boolean</span>[] visited, ArrayList&lt;Integer&gt; order)</span> </span>&#123;</span><br><span class="line">  visited[v] = <span class="keyword">true</span>;</span><br><span class="line">  order.add(v);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> w : graph.get(v))</span><br><span class="line">    <span class="keyword">if</span> (!visited[w])</span><br><span class="line">      dfs(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-图的联通分量个数"><a href="#2-1-图的联通分量个数" class="headerlink" title="2.1 图的联通分量个数"></a>2.1 图的联通分量个数</h5><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598615267760.png" alt="1598615267760"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 新建图结构.....</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> v : graph.keySet())&#123;</span><br><span class="line">    <span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line">      dfs(v, visited);</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">  visited[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> w : graph.get(v))</span><br><span class="line">    <span class="keyword">if</span> (!visited[w])</span><br><span class="line">      dfs(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-单源最短路径问题"><a href="#2-2-单源最短路径问题" class="headerlink" title="2.2 单源最短路径问题"></a>2.2 单源最短路径问题</h5><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598617300733.png" alt="1598617300733"></p><hr><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598617470948.png" alt="1598617470948"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以s为起点，记录从s到图中其他</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SingleSourcePath</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 新建图结构.....</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">  <span class="comment">// 记录前驱节点</span></span><br><span class="line">  <span class="keyword">int</span>[] pre = <span class="keyword">new</span> <span class="keyword">int</span>[V];</span><br><span class="line">  </span><br><span class="line">  dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> parent)</span></span>&#123;</span><br><span class="line">  visited[v] = <span class="keyword">true</span>;</span><br><span class="line">  pre[v] = parent;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> w : graph.get(v))</span><br><span class="line">    <span class="keyword">if</span> (!visited[w])</span><br><span class="line">      dfs(w, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断t节点是否与源节点联通</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnectedTo</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> visited[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取从源节点到t节点的路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">path</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">  <span class="keyword">if</span> (!isConnectedTo(t))</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> cur = t;</span><br><span class="line">  <span class="keyword">while</span> (cur != s) &#123;</span><br><span class="line">    res.add(cur);</span><br><span class="line">    cur = pre[cur];</span><br><span class="line">  &#125;</span><br><span class="line">  res.add(s);</span><br><span class="line"></span><br><span class="line">  Collections.reverse(res);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法, 以0为原点，生成图的前缀列表</span></span><br><span class="line"><span class="comment">// 以上图为例：图的前缀列表为[0, 0, 3, 1, 1, 2]</span></span><br><span class="line">SingleSourcePath(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 0-&gt;4的路径</span></span><br><span class="line">path(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 0-&gt;6的路径</span></span><br><span class="line">path(<span class="number">0</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><h5 id="2-3-单源最短路径问题优化-剪枝"><a href="#2-3-单源最短路径问题优化-剪枝" class="headerlink" title="2.3  单源最短路径问题优化(剪枝)"></a>2.3  单源最短路径问题优化(剪枝)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到目标路径就停止递归</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  visited[v] = <span class="keyword">true</span>;</span><br><span class="line">  pre[v] = parent;</span><br><span class="line"><span class="comment">// t是目标节点</span></span><br><span class="line">  <span class="keyword">if</span> (v == t)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> w : graph.get(v))</span><br><span class="line">    <span class="keyword">if</span> (!visited[w])</span><br><span class="line">      <span class="keyword">if</span> (dfs(w, v))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-4-无向图的环检测"><a href="#2-4-无向图的环检测" class="headerlink" title="2.4 无向图的环检测"></a>2.4 无向图的环检测</h5><p>其实就是看有没有一条自己到自己的路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以s为起点，记录从s到图中其他</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">CycleDetection</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 新建图结构.....</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">    <span class="keyword">if</span> (!visited[i])</span><br><span class="line">      <span class="keyword">if</span> (dfs(i, i)) &#123;</span><br><span class="line">        hasCycle = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">return</span> hasCycle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> parent)</span></span>&#123;</span><br><span class="line">  visited[v] = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> w : graph.get(v))</span><br><span class="line">    <span class="comment">// 访问过并且不是上一个节点则表明出现环</span></span><br><span class="line">    <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dfs(w, v))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (w != parent)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-5-二分图检测"><a href="#2-5-二分图检测" class="headerlink" title="2.5 二分图检测"></a>2.5 二分图检测</h5><ol><li>相亲网站，左边是男士，右边是女士</li><li>选课，左边是学生，右边是课程</li><li>……</li></ol><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598623085038.png" alt="1598623085038"></p><p><strong>不要以为看了上图就以为二分图能很容易看出来，其实如下图所示，右边的图其实就是左边的图，那你能看出来右边的图是二分图吗？</strong></p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598623227273.png" alt="1598623227273"></p><p><strong>正因为二分图无法简单地判断出来，所以我们需要一种算法帮我们判定，这种算法称之为：染色。染色就是说在DFS遍历图的过程中对节点进行赋值，比如我们用蓝色和绿色去染色，看看在DFS结束后，图中的任意一条边是否能一遍连接蓝色点，一边连接绿色点</strong></p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598623568587.png" alt="1598623568587"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">BipartitionDetection</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 新建图结构.....</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">  <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[V];</span><br><span class="line">  <span class="keyword">boolean</span> isBipartite = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i ++)&#123;</span><br><span class="line">    <span class="comment">// 表示所有节点都没染色</span></span><br><span class="line">    colors[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">      <span class="keyword">if</span>(!dfs(i, <span class="number">0</span>))&#123;</span><br><span class="line">        isBipartite = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isBipartite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若是二分图则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> color)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  visited[v] = <span class="keyword">true</span>;</span><br><span class="line">  colors[v] = color;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> w: graph.get(v))&#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">      <span class="comment">// 1 - color: 若当前节点颜色为0，则下一节点颜色为1; 若当前节点颜色为1，则下一节点颜色为0</span></span><br><span class="line">      <span class="keyword">if</span>(!dfs(w, <span class="number">1</span> - color)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(colors[w] == colors[v])&#123;</span><br><span class="line">      <span class="comment">// v,w 两端颜色相同</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、拓扑排序（TurboSort），基本等同于广度优先遍历"><a href="#三、拓扑排序（TurboSort），基本等同于广度优先遍历" class="headerlink" title="三、拓扑排序（TurboSort），基本等同于广度优先遍历"></a>三、拓扑排序（TurboSort），基本等同于广度优先遍历</h4><p>拓扑排序主要是针对有向无环图的算法，定义是：通过该算法得出一个序列，使得有向无环图（DAG）中的任意一对顶点若存在边&lt;u,v&gt;，则在拓扑排序得到的线性序列中，顶点u一定出现在顶点v之前，即保证依赖关系的顺序性。</p><p>可能这么描述稍微有一点学术，什么意思呢，通俗上讲就是我们要解决依赖关系，比如你想要一个孙子，怎么办？首先，你要有一个儿子，儿子哪里来，得自己生啊，怎么生呢？你要结婚啊！跟谁结婚呢？你要先有个对象啊！有对象就能结婚了么？不，你没车没房没彩礼，你丈母娘不能同意啊！所以，要想达到某一个节点，你需要先搞定其中的必要条件，当然，这些必要条件对于同一个节点的入度节点是不要求顺序的，比如你先买车还是先买房，你丈母娘都是能同意的，但是你都得买，你必须把你丈母娘的入度减到零，才能搞定丈母娘！所以这个Case的拓扑排序如下图：</p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/2019112517170990.png" alt="img"></p><p> 如上，拓扑排序就是在各种依赖关系中找出一些合理的线性关系来满足各种依赖，例如我们大学上课，选课时某些课程存在前驱课程，如统计学习的前驱课程有高数，现代等，没有相关基础，我们没办法学好这些高等课程。下面例题我将会介绍LeetCode上一道这样的拓扑排序题目。类似的还有项目工程关系，多个项目之间也存在依赖的先后次序。</p><p><strong>下面的图片给出了广度优先搜索的可视化流程，来自<a href="https://leetcode-cn.com/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/">力扣官方题解</a></strong></p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/fig1.png" alt="img"></p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/fig2.png" alt="img"></p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/fig3.png" alt="img"></p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/fig4.png" alt="img"></p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/fig5.png" alt="img"></p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/fig6.png" alt="img"></p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/fig7.png" alt="img"></p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/fig8.png" alt="img"></p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/fig9.png" alt="img"></p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/fig10.png" alt="img"></p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/fig11.png" alt="img"></p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/fig12.png" alt="img"></p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/fig13.png" alt="img"></p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/fig14.png" alt="img"></p><p>值得注意的是，拓扑排序不能应用于有环图，因为我们的前提条件是总能至少在图中找到一个入度为0的顶点开始拓扑，但是当图中存在环时，我们在这个环中找不到任意一个入度为0顶的点。</p><p>之前介绍拓扑排序是利用的广度优先的思想，也是借助队列这个辅助数据结构、之前在<strong>BFS问题模板里也有说明</strong>，把图中所有度为1的节点先入队</p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598583520985.png" alt="1598583520985"></p><p>具体的算法流程是：</p><ol><li>首先建立一个countArr数组并统计每一个顶点的入度填到对应数组中；通过遍历，首先将所有入度为0的节点入队，并将节点总数vexCount相应减少。</li><li>然后利用广度优先搜索的思路进行循环，里面注意的操作是：每当出队一个顶点时，我们将以该顶点为弧尾的弧顶顶点对应的入度countArr[i]减一，并判断该countArr[i]是否为0，为零则将该元素入队，并将vexCount减一，循环直至队列为空。</li><li>就这样一层一层向内剥洋葱，最后判断vexCount是否为0，如果为0，说明我们洋葱剥成功，如果不为零，则说明这个洋葱有心儿，即成环了，无法彻底剥开。最后输出的顶点出队顺序就是该图对应的一个拓扑序列。</li></ol><p><strong>这里额外考虑一点，使用<a href="./visited%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.md">visited数组的使用方法</a>判断拓扑排序算法是否需要使用visited辅助</strong>，观察下图分析从A到D有两条路径A-&gt;D 和 A-&gt;B-&gt;C-&gt;D，当先通过A-&gt;D这条路线到达D之后不能把visited[D]设为true，因为之后还有一条路线A–&gt;B-&gt;C-&gt;D还需要被考虑到。所以拓扑排序是和路径相关的，所以不能设置<code>visited</code>数组</p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1598586512511.png" alt="1598586512511"></p><p>下面以LeetCode的<a href="https://leetcode-cn.com/problems/course-schedule-ii/">Leetcode210. 课程表 II</a>进行介绍：</p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/2019112517170955.png" alt="img"></p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/2019112517170944.png" alt="img"></p><p>这一题就是典型的拓扑排序，没有别的套路，拓扑排序直接上，这题较为简单，没有对拓扑排序的线性序列进行过多的要求，返回一个正确的序列即可。对于较为难的题我们需要对顶点出队的顺序进行控制，或者进行二次的拓扑排序，以满足题目对输入序列额外的要求，如LeetCode的<a href="https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/">Leetcode1203. 项目管理</a></p><p><strong>建图方法详见和BFS问题模板详见<a href="./BFS%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF.md">BFS问题模板</a></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 存储每个节点的入度</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indeg;</span><br><span class="line">    <span class="comment">// 存储答案</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        indeg.resize(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].push_back(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="comment">// 将所有入度为 0 的节点放入队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="comment">// 从队首取出一个节点</span></span><br><span class="line">            <span class="keyword">int</span> u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">// 放入答案中</span></span><br><span class="line">            result.push_back(u);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v: edges[u]) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="comment">// 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span></span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.size() != numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="3-1-拓扑排序也可以用来判定图是否有环路"><a href="#3-1-拓扑排序也可以用来判定图是否有环路" class="headerlink" title="3.1 拓扑排序也可以用来判定图是否有环路"></a>3.1 拓扑排序也可以用来判定图是否有环路</h5><p><strong>只需要在<code>Leetcode210. 课程表 II</code>里修改一点点点点代码即可：用visited计数</strong></p><p><strong>这题对应<a href="https://leetcode-cn.com/problems/course-schedule/">Leetcode207. 课程表</a></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indeg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        indeg.resize(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].push_back(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> visited = <span class="number">0</span>; <span class="comment">// 添加visited计数器</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            ++visited;</span><br><span class="line">            <span class="keyword">int</span> u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v: edges[u]) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> visited == numCourses;<span class="comment">// 判断计数器结果是否等于所有课程数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode329. 矩阵中的最长递增路径</title>
      <link href="post/472e8caf.html"/>
      <url>post/472e8caf.html</url>
      
        <content type="html"><![CDATA[<p><strong>本题设计到记忆化搜索，因为若不使用，则不管是DFS还是BFS都会超时</strong></p><p><strong>转载自：<a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/solution/ncha-shu-de-ceng-xu-bian-li-by-leetcode/">Leetcode题解（力扣 (LeetCode)），略有增删</a></strong></p><a id="more"></a><h4 id="一、BFS"><a href="#一、BFS" class="headerlink" title="一、BFS"></a>一、BFS</h4><p>建图方法详见和BFS问题模板详见<a href="./BFS%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF.md">BFS问题模板</a>，对是否使用<code>visited</code>数组的分析参考<a href="./visited%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.md">visited数组的使用方法</a></p><p><strong>转载自：<a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/solution/dfshe-bfsliang-chong-xie-fa-by-lartecy/">Leetcode题解（lartecy），略有增删</a></strong></p><ol><li>为了防止重复计算，可以使用一个<code>memo[][]</code>数组来记录之前计算过的值，为什么需要记忆化搜索呢，因为计算a-&gt;b-&gt;c之间的最长递增序列长度，需要先计算a-&gt;b的最长递增序列长度，明显可以看出有重复计算。</li><li>在每个起点处，维护一个队列，存入需要遍历的坐标，同时维护一个表示路径长度(层数)的变量count，找到合法的位置坐标就加入队列，同时更新memo，保证memo表示的是当前最大的长度</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> n  = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">int</span> len = queue.size();</span><br><span class="line">          count++;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] d : dirs) &#123;</span><br><span class="line">              <span class="keyword">int</span> newX = cur[<span class="number">0</span>] + d[<span class="number">0</span>];</span><br><span class="line">              <span class="keyword">int</span> newY = cur[<span class="number">1</span>] + d[<span class="number">1</span>];</span><br><span class="line">              <span class="keyword">if</span> (newX &lt; <span class="number">0</span> || newX &gt;= m || newY &lt; <span class="number">0</span> || newY &gt;= n || </span><br><span class="line">                  matrix[newX][newY] &lt;= matrix[cur[<span class="number">0</span>]][cur[<span class="number">1</span>]] || count &lt;= memo[newX][newY]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              memo[newX][newY] = count;</span><br><span class="line">              res = Math.max(res, count);</span><br><span class="line">              queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newX, newY&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、DFS"><a href="#二、DFS" class="headerlink" title="二、DFS"></a>二、DFS</h4><ol><li><p>状态：二维数组下标，用<code>row和col</code>表示。<code>recursion(matrix, row, col)</code>表示以[row, col]为起点的最长递增序列长度，matrix为原始数组，但是因为本题需要用到记忆化搜素，所以用一个memo数组保存已经计算过的点的值：<code>recursion(int[][] matrix, int row, int column, int[][] memo)</code></p></li><li><p>递归终止条件：没有递归终止条件，单纯返回一个当前位置的最长递增序列长度<code>return memo[row][column];</code></p><p><strong>用动态规划的角度表示最小子问题为：</strong><code>return dp[row][column]</code></p></li><li><p>状态转移方程(可能涉及到多次if条件判断)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> newRow = row + dir[<span class="number">0</span>], newColumn = column + dir[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="number">0</span> &amp;&amp; newColumn &lt; columns </span><br><span class="line">&amp;&amp; matrix[newRow][newColumn] &gt; matrix[row][column]) &#123;</span><br><span class="line">  memo[row][column] = Math.max(memo[row][column], dfs(matrix, newRow, newColumn, memo) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用动态规划的角度表示转移方程为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="number">0</span> &amp;&amp; newColumn &lt; columns </span><br><span class="line">&amp;&amp; matrix[newRow][newColumn] &gt; matrix[row][column]) &#123;</span><br><span class="line"> dp[row][col] = Math.max(memo[row][column], dp[newRow, newColumn] + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回最终状态：return recursion(row, col)；</p><p><strong>用动态规划的角度表示最终返回值为：<code>return dp[row][col]</code></strong></p></li></ol><p><strong>完整代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> rows, columns;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.size() == <span class="number">0</span> || matrix[<span class="number">0</span>].size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rows = matrix.size();</span><br><span class="line">        columns = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">auto</span> memo = <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; (rows, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; (columns));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; ++j) &#123;</span><br><span class="line">                ans = max(ans, dfs(matrix, i, j, memo));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix, <span class="keyword">int</span> row, <span class="keyword">int</span> column, <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[row][column] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[row][column];</span><br><span class="line">        &#125;</span><br><span class="line">        ++memo[row][column];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> newRow = row + dirs[i][<span class="number">0</span>], newColumn = column + dirs[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="number">0</span> &amp;&amp; </span><br><span class="line">                newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[row][column]) &#123;</span><br><span class="line">                memo[row][column] = max(memo[row][column], dfs(matrix, newRow, newColumn, memo) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[row][column];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>visited数组的使用方法</title>
      <link href="post/e9040c40.html"/>
      <url>post/e9040c40.html</url>
      
        <content type="html"><![CDATA[<p><strong><code>visited数组</code>一般在设计二维数组的题目使用BFS或者DFS算法，或者使用回溯算法时常用的一种辅助数据结构，是用作防止元素被重复访问导致程序处理时间变长或者数据栈溢出。但也不是只要碰到上述的几种类型题目就一定要用到<code>visited</code>数组，下面介绍几种判别是否使用的区分条件</strong></p><a id="more"></a><p><strong><u>大前提：题目使用BFS, DFS, 回溯等算法</u></strong></p><ul><li><p>若题目不需要用元素之间的<strong>联系</strong>做题，也称作<strong>路径无关</strong>，则需要使用<code>visited</code>数组：什么叫没有联系呢，比如<a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a>，我要从右下角用BFS或者DFS判断右上角那块是不是岛，我有两种方法，一种是通过橘色路线，另一种是通过绿色路线。但是问题是我采用这两条路线有什么差别吗？我反正就单纯想判断右上角那块是不是岛，假设我第一次通过橘色路线判断了右上角那块是岛，<strong>虽然我还有一条路线，但我又何必再次通过绿色路线再判断一次这是不是块岛呢？</strong>这就叫做没有联系，路径无关，右上和右下这两块不能通过路线这一特性进行联系，结果与路线不相关，不相关就是没联系。因此我们可以设置<code>visited[右上角] = true</code>，说明，<strong>我已经访问过这位置的元素了，反正就是证明我是不是一块岛，现在已经证明完毕了，就别再通过其他乱七八糟的路线访问我啦。就算你还有10000000条不同的路径能到达这个位置那又如何？你还能通过不同路径一下会证明我是岛，一会证明我不是岛？客观现实不受主观意愿影响懂不懂？</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="./visited%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/1598577976003.png" alt="1598577976003"></p></li><li><p>若题目需要元素之间的<strong>联系</strong>做题，也称作<strong>路径相关</strong>，则一定不会使用<code>visited</code>数组：比如<a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a>，我仍然还是从右下到右上，但是题目要求的是最长递增路径的长度。按照橘色路径走，最长路径为2；但是按照绿色路径走，最长路径就为3。虽然我第一次通过橘色走过了一条长为2的递增路径，但是我怎么知道我通过其他路劲不会走出一条更长的路呢。所以不能使用<code>visited</code>数组，我虽然已经访问过了右上角的元素，但是我不会阻碍它被之后的路径访问。这就叫元素之间有联系，也称路径相关，在此题中的联系为<strong>谁更大</strong>。</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="./visited%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/1598578992757.png" alt="1598578992757"></p><ul><li>元素之间的联系有很多种，比如大小，异同等等</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> 回溯 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode690. 员工的重要性</title>
      <link href="post/8dda7622.html"/>
      <url>post/8dda7622.html</url>
      
        <content type="html"><![CDATA[<p>建图方法详见和BFS问题模板详见<a href="./BFS%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF.md">BFS问题模板</a></p><p><strong>转载自：<a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/solution/ncha-shu-de-ceng-xu-bian-li-by-leetcode/">Leetcode题解（力扣 (LeetCode)），略有增删</a></strong></p><a id="more"></a><p>这道题无非就是<strong>求以某个节点为根节点的树中所有节点值的总和</strong></p><p><strong>完整代码</strong><br><strong>每部分代码你都能在BFS模板中找到对应原型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getImportance</span><span class="params">(List&lt;Employee&gt; employees, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Employee&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(employees.size());</span><br><span class="line">        <span class="keyword">for</span> (Employee employee : employees) &#123;</span><br><span class="line">            map.put(employee.id, employee);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 加入队尾</span></span><br><span class="line">        queue.offer(id);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 队头拿出</span></span><br><span class="line">                Integer currentId = queue.poll();</span><br><span class="line"></span><br><span class="line">                Employee currentEmployee = map.get(currentId);</span><br><span class="line">                res += currentEmployee.importance;</span><br><span class="line">                <span class="keyword">for</span> (Integer eid : currentEmployee.subordinates) &#123;</span><br><span class="line">                    queue.offer(eid);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode491. 递增子序列</title>
      <link href="post/7df2bdfd.html"/>
      <url>post/7df2bdfd.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/increasing-subsequences/solution/jin-tian-wo-you-shuang-ruo-zhuo-neng-miao-dong-la-/">Leetcode题解（Sweetiee），略有增删</a></strong></p><a id="more"></a><p><strong>请严格按照<a href="./Leetcode46-%E5%85%A8%E6%8E%92%E5%88%97.md">回溯模板</a>所提到的格式分析与编写代码</strong></p><p><strong>几点需要注意</strong></p><ol><li>在回溯模板里，是使用<code>visited</code>来确保元素不会重复访问，但是本题是求<strong>递增</strong>的一位数组，是从左往右的线性变化，访问过了就再也回不去了(哲学中时间的线性性质)，这跟在一维数组里<strong>求组合数</strong>还不一样，从左到右已经访问过的元素是没用了的；跟二维数组也不一样，二维数组里某个位置元素可以<strong>从它下面的元素向上访问</strong>，<strong>也可以从它右边的元素向左访问</strong>….所以需要设置<code>visited</code>数组。本题通过<code>int i = idx + 1</code>就可以很好保证元素不用重复访问</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义全局变量保存结果</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSubsequences(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// idx 初始化为 -1，开始 dfs 搜索。</span></span><br><span class="line">        dfs(nums, -<span class="number">1</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> idx, List&lt;Integer&gt; curList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只要当前的递增序列长度大于 1，就加入到结果 res 中，然后继续搜索递增序列的下一个值。</span></span><br><span class="line">        <span class="keyword">if</span> (curList.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在 [idx + 1, nums.length - 1] 范围内遍历搜索递增序列的下一个值。</span></span><br><span class="line">        <span class="comment">// 借助 set 对 [idx + 1, nums.length - 1] 范围内的数去重。</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx + <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 1. 如果 set 中已经有与 nums[i] 相同的值了，说明加上 nums[i] 后的所有可能的递增序列之前已经被搜过一遍了，因此停止继续搜索。</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(nums[i])) &#123; </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            <span class="comment">// 2. 如果 nums[i] &gt;= nums[idx] 的话，说明出现了新的递增序列，因此继续 dfs 搜索</span></span><br><span class="line">            <span class="keyword">if</span> (idx == -<span class="number">1</span> || nums[i] &gt;= nums[idx]) &#123;</span><br><span class="line">                curList.add(nums[i]);</span><br><span class="line">                dfs(nums, i, curList);</span><br><span class="line">                curList.remove(curList.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode559. N叉树的最大深度</title>
      <link href="post/330cf4b.html"/>
      <url>post/330cf4b.html</url>
      
        <content type="html"><![CDATA[<p>建图方法详见和BFS问题模板详见<a href="./BFS%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF.md">BFS问题模板</a></p><p><strong>转载自：<a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/solution/c-san-chong-jing-dian-fang-fa-jie-ti-by-pris_bupt/">Leetcode题解（Iris_bupt），略有增删</a></strong></p><a id="more"></a><p>本道题目的是求树的最大高度，不管是N叉树还是二叉树，像这种有明显<strong>层级</strong>概念的题用BFS做就对了</p><p><strong>完整代码</strong></p><p><strong>每部分代码你都能在BFS模板中找到对应原型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt;<span class="built_in">queue</span>;</span><br><span class="line">    <span class="built_in">queue</span>.push(root);</span><br><span class="line">    <span class="keyword">int</span> max_depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">queue</span>.empty()) &#123;</span><br><span class="line">        max_depth++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> size = <span class="built_in">queue</span>.size(); size; size--) &#123;</span><br><span class="line">            Node* curr = <span class="built_in">queue</span>.front(); <span class="built_in">queue</span>.pop();</span><br><span class="line">            <span class="keyword">for</span> (Node* it : curr-&gt;children)</span><br><span class="line">                <span class="built_in">queue</span>.push(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode542. 01 矩阵</title>
      <link href="post/376b6661.html"/>
      <url>post/376b6661.html</url>
      
        <content type="html"><![CDATA[<p>建图方法详见和BFS问题模板详见<a href="./BFS%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF.md">BFS问题模板</a></p><p><strong>转载自：<a href="https://leetcode-cn.com/problems/01-matrix/solution/01ju-zhen-by-leetcode-solution/">Leetcode题解（力扣官方题解），略有增删</a></strong></p><a id="more"></a><h4 id="一、BFS解法"><a href="#一、BFS解法" class="headerlink" title="一、BFS解法"></a>一、BFS解法</h4><p>首先把每个源点 0 入队，然后从各个 0 同时开始一圈一圈的向 11 扩散（每个 11 都是被离它最近的 00 扩散到的 ），扩散的时候可以设置 dist 数组来记录距离（即扩散的层次）并同时使用 visitied 数组标志是否访问过。</p><p><strong>完整代码</strong></p><p><strong>每部分代码你都能在BFS模板中找到对应原型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; updateMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dist(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="comment">// 将所有的 0 添加进初始队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.push(&#123;i, j&#125;);</span><br><span class="line">                    visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 广度优先搜索</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">while</span>(size)&#123;</span><br><span class="line">                <span class="keyword">auto</span> [i, j] = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; ++d) &#123;</span><br><span class="line">                    <span class="keyword">int</span> newX = i + dirs[d][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> newY = j + dirs[d][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (newX &gt;= <span class="number">0</span> &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newY &lt; n &amp;&amp; !visited[newX][newY]) &#123;</span><br><span class="line">                        dist[newX][newY] = dist[i][j] + <span class="number">1</span>;</span><br><span class="line">                        q.push(&#123;newX, newY&#125;);</span><br><span class="line">                        visited[newX][newY] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="二、动态规划解法"><a href="#二、动态规划解法" class="headerlink" title="二、动态规划解法"></a>二、动态规划解法</h4><ol><li><p>状态：二维数组下标(变化量)，用<code>i</code>和<code>j</code>表示。<code>dp[i][j]</code>表示当前位置元素到最近的0的距离</p></li><li><p>最小状态：如果二维数组某元素本身就是0，则dp[i] [j]就是0</p></li><li><p>状态转移方程(通过对状态的循环多次，有几个状态就有几层循环，对立相反的状态只需写两行代码即可，不需要循环)：<strong>有两个状态量，则有两层嵌套循环</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很明显在二维数组里，某个位置的元素值就是由它为中心的九宫格位置元素演变过来的，本题是上下左右</span></span><br><span class="line"><span class="comment">// 但是这道题比较棘手，因为对于简单的二维动态规划，某个位置的值都是从&quot;单侧&quot;递推过来的</span></span><br><span class="line"><span class="comment">// 比如从左到右，从右下到左上，做右上到左下.....但是本道题是上下左右都能对中间元素值产生影响</span></span><br><span class="line"><span class="comment">// 根据只能由&quot;已知量推未知量&quot;的原则，无法一次性完成dp数组的构建，所以需要if判断分别从两侧往中间推</span></span><br><span class="line"><span class="comment">// 最后的结果对二者取最小值</span></span><br></pre></td></tr></table></figure></li><li><p>返回最终状态：return dp[n] [m]</p></li></ol><p><strong>完整代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; updateMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// 初始化动态规划的数组，所有的距离值都设置为一个很大的数</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dist(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, INT_MAX / <span class="number">2</span>));</span><br><span class="line">        <span class="comment">// 如果 (i, j) 的元素为 0，那么距离为 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dist[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有 水平向左移动 和 竖直向上移动，注意动态规划的计算顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dist[i][j] = min(dist[i][j], dist[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dist[i][j] = min(dist[i][j], dist[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有 水平向左移动 和 竖直向下移动，注意动态规划的计算顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; m) &#123;</span><br><span class="line">                    dist[i][j] = min(dist[i][j], dist[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dist[i][j] = min(dist[i][j], dist[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有 水平向右移动 和 竖直向上移动，注意动态规划的计算顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dist[i][j] = min(dist[i][j], dist[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                    dist[i][j] = min(dist[i][j], dist[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有 水平向右移动 和 竖直向下移动，注意动态规划的计算顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; m) &#123;</span><br><span class="line">                    dist[i][j] = min(dist[i][j], dist[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                    dist[i][j] = min(dist[i][j], dist[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode529. 扫雷游戏</title>
      <link href="post/7c69f2.html"/>
      <url>post/7c69f2.html</url>
      
        <content type="html"><![CDATA[<p>建图方法详见和BFS问题模板详见<a href="./BFS%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF.md">BFS问题模板</a></p><p><strong>转载自：<a href="https://leetcode-cn.com/problems/minesweeper/solution/cong-qi-dian-kai-shi-dfs-bfs-bian-li-yi-bian-ji-ke/">Leetcode题解（Sweetiee），略有增删</a></strong></p><a id="more"></a><p><strong>完整代码</strong></p><p><strong>每部分代码你都能在BFS模板中找到对应原型</strong></p><p>这里要注意的是，与树的 BFS 不一样（每个节点只有一个父亲节点），本题图中的点会由多个点达到，因此需要加上 boolean[][] visited 数组记录访问标志，防止每个点重复入队而超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义 8 个方向</span></span><br><span class="line">    <span class="keyword">int</span>[] dx = &#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dy = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</span><br><span class="line">        <span class="comment">// 1. 若起点是雷，游戏结束，直接修改 board 并返回。</span></span><br><span class="line">        <span class="keyword">int</span> x = click[<span class="number">0</span>], y = click[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (board[x][y] == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">            board[x][y] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> board;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 若起点是空地，则将起点入队，从起点开始向 8 邻域的空地进行宽度优先搜索。</span></span><br><span class="line">        <span class="keyword">int</span> m = board.length, n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;x, y&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] point = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> i = point[<span class="number">0</span>], j = point[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 判断空地 (i, j) 周围是否有雷</span></span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> newX = i + dx[k];</span><br><span class="line">                <span class="keyword">int</span> newY = j + dy[k];</span><br><span class="line">                <span class="keyword">if</span> (newX &lt; <span class="number">0</span> || newX &gt;= board.length || newY &lt; <span class="number">0</span> || newY &gt;= board[<span class="number">0</span>].length) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (board[newX][newY] == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若空地 (i, j) 周围有雷，则将该位置修改为雷数；</span></span><br><span class="line">          <span class="comment">// 否则将该位置更新为 ‘B’，并将其 8 邻域中的空地入队，继续进行 bfs 搜索。</span></span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                board[i][j] = (<span class="keyword">char</span>)(cnt + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                board[i][j] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> newX = i + dx[k];</span><br><span class="line">                    <span class="keyword">int</span> newY = j + dy[k];</span><br><span class="line">                    <span class="keyword">if</span> (newX &lt; <span class="number">0</span> || newX &gt;= board.length || newY &lt; <span class="number">0</span> || newY &gt;= board[<span class="number">0</span>].length </span><br><span class="line">                        || board[newX][newY] != <span class="string">&#x27;E&#x27;</span> || visited[newX][newY]) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    visited[newX][newY] = <span class="keyword">true</span>;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;newX, newY&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode429. N叉树的层序遍历</title>
      <link href="post/fbf15006.html"/>
      <url>post/fbf15006.html</url>
      
        <content type="html"><![CDATA[<p>建图方法详见和BFS问题模板详见<a href="./BFS%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF.md">BFS问题模板</a></p><p><strong>转载自：<a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/solution/ncha-shu-de-ceng-xu-bian-li-by-leetcode/">Leetcode题解（力扣 (LeetCode)），略有增删</a></strong></p><a id="more"></a><p><strong>完整代码</strong><br><strong>每部分代码你都能在BFS模板中找到对应原型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;      </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Node node = queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">              </span><br><span class="line">              <span class="comment">// 这行代码等价于对节点相邻元素的遍历</span></span><br><span class="line">              <span class="comment">// 因为题目给定了一个节点的所有子节点children, 直接拿来用即可</span></span><br><span class="line">                queue.addAll(node.children);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode513. 找树左下角的值</title>
      <link href="post/aeedec6c.html"/>
      <url>post/aeedec6c.html</url>
      
        <content type="html"><![CDATA[<p>建图方法详见和BFS问题模板详见<a href="./BFS%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF.md">BFS问题模板</a></p><p><strong>转载自：<a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/solution/bfsgai-jin-fa-jian-dan-yi-dong-jie-jin-shuang-bai-/">Leetcode题解（quantbruce），略有增删</a></strong></p><a id="more"></a><p>本题要求<strong>最后一层</strong>的元素，涉及到层数，参考BFS模板里第二种形式的描述：如果题目涉及到层数，步数……则使用BFS解题</p><p><strong>注意几点：</strong></p><ol><li>二叉树节点的相邻节点只有左右子节点这两个，所以可以使用两个if替代for循环</li><li>先入右节点再入左节点，让右节点先出队</li></ol><p><strong>完整代码</strong><br><strong>每部分代码你都能在BFS模板中找到对应原型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                result = node.val;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode310. 最小高度树</title>
      <link href="post/f0d1bb1d.html"/>
      <url>post/f0d1bb1d.html</url>
      
        <content type="html"><![CDATA[<p>建图方法详见和BFS问题模板详见<a href="./BFS%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF.md">BFS问题模板</a></p><p><strong>转载自：<a href="https://leetcode-cn.com/problems/minimum-height-trees/solution/zui-rong-yi-li-jie-de-bfsfen-xi-jian-dan-zhu-shi-x/">Leetcode题解（小鑫），略有增删</a></strong></p><a id="more"></a><p><strong>本题简而言之就是<code>剥洋葱</code>，从外到内二分图的距离，找到最内层的元素</strong></p><p>我们从边缘开始，先找到所有出度为1的节点，然后把所有出度为1的节点进队列，然后不断地bfs，最后找到的就是两边同时向中间靠近的节点，那么这个中间节点就相当于把整个距离二分了，那么它当然就是到两边距离最小的点啦，也就是到其他叶子节点最近的节点了。</p><ol><li>因为题目已经给出图的点与边的关系，所以在进行队列操作之前就使用邻接矩阵方式构造图</li><li>使用保存节点<strong>度</strong>值的数组来对图节点元素出入队进行辅助操作</li></ol><p><strong>完整代码</strong><br><strong>每部分代码你都能在BFS模板中找到对应原型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">/*如果只有一个节点，那么他就是最小高度树*/</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*建立各个节点的出度表*/</span></span><br><span class="line">        <span class="keyword">int</span>[] degree = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">/*建立图关系，在每个节点的list中存储相连节点*/</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            map.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">            degree[edge[<span class="number">0</span>]]++;</span><br><span class="line">            degree[edge[<span class="number">1</span>]]++;<span class="comment">/*度++*/</span></span><br><span class="line">            map.get(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);<span class="comment">/*添加相邻节点*/</span></span><br><span class="line">            map.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*建立队列*/</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">/*把所有出度为1的节点，也就是叶子节点入队*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (degree[i] == <span class="number">1</span>) queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*循环条件当然是经典的不空判断*/</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            res = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">/*这个地方注意，我们每层循环都要new一个新的结果集合，</span></span><br><span class="line"><span class="comment">            这样最后保存的就是最终的最小高度树了*/</span></span><br><span class="line">            <span class="keyword">int</span> size = queue.size();<span class="comment">/*这是每一层的节点的数量*/</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">                res.add(cur);<span class="comment">/*把当前节点加入结果集，不要有疑问，为什么当前只是叶子节点为什么要加入结果集呢?</span></span><br><span class="line"><span class="comment">                因为我们每次循环都会新建一个list，所以最后保存的就是最后一个状态下的叶子节点，</span></span><br><span class="line"><span class="comment">                这也是很多题解里面所说的剪掉叶子节点的部分，你可以想象一下图，每层遍历完，</span></span><br><span class="line"><span class="comment">                都会把该层（也就是叶子节点层）这一层从队列中移除掉，</span></span><br><span class="line"><span class="comment">                不就相当于把原来的图给剪掉一圈叶子节点，形成一个缩小的新的图吗*/</span></span><br><span class="line">                List&lt;Integer&gt; neighbors = map.get(cur);</span><br><span class="line">                <span class="comment">/*这里就是经典的bfs了，把当前节点的相邻接点都拿出来，</span></span><br><span class="line"><span class="comment">                * 把它们的出度都减1，因为当前节点已经不存在了，所以，</span></span><br><span class="line"><span class="comment">                * 它的相邻节点们就有可能变成叶子节点*/</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : neighbors) &#123;</span><br><span class="line">                    degree[neighbor]--;</span><br><span class="line">                    <span class="keyword">if</span> (degree[neighbor] == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">/*如果是叶子节点我们就入队*/</span></span><br><span class="line">                        queue.offer(neighbor);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;<span class="comment">/*返回最后一次保存的list*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode127. 单词接龙</title>
      <link href="post/cf135714.html"/>
      <url>post/cf135714.html</url>
      
        <content type="html"><![CDATA[<p>建图方法详见和BFS问题模板详见<a href="./BFS%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF.md">BFS问题模板</a></p><p><strong>转载自：<a href="https://leetcode-cn.com/problems/word-ladder/solution/yan-du-you-xian-bian-li-shuang-xiang-yan-du-you-2/">Leetcode题解（liweiwei1419），略有增删</a></strong></p><a id="more"></a><ol><li><p>通过建图模板里对题目的分析，我们观察到题目里的<strong>转换</strong>刚好就契合建图模板里的<strong>改变一次</strong>说法，所以可以通过模板建图，找到只变化一次的情况然后连接。只不过模板里说的是字母之间的转换，而本道题是单词之间的转换，但本质相同</p><p><strong>注：比如说从<code>hit</code>到<code>hot</code>只是中间的那个单词变化了<code>一次</code>，从<code>log</code>到<code>cog</code>只是第一个单词变化了<code>一次</code></strong></p></li></ol><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/1598442144065.png" alt="1598442144065"></p><ol start="2"><li>我们在遍历一开始，把所有的单词列表放进一个哈希表中，然后在遍历的时候构建图，每一次得到在单词列表里可以转换的单词，<strong>并把它推入队中</strong></li><li>这里说明一下在BFS模板里强调的<strong>要确定当前遍历到了哪一层</strong>具体是什么意思：比如<code>lot</code>这个单词是从<code>hit</code>变化了两次才形成的，而<code>dot</code>也是由<code>hit</code>变化了两次形成的，所以<code>lot</code>和<code>dot</code>是位于同一层，也可以表示为<strong>走了两步</strong>。那为什么要强调同一层呢？因为<strong>同一层的节点是不能再相互遍历的</strong>，比如从<code>lot</code>到<code>cog</code>需要变化两次，而如果<code>lot</code>先遍历同层元素，比如<code>dot</code>，那么最小需要从lot——&gt;dot——&gt;dog——&gt;cog，即三次才能访问到。这比刚才的次数要多，不符合题意，所以不能访问同一层元素。</li></ol><p><strong>模板化书写，根据公式分析，公式里没提及的全是固定套路代码</strong></p><ol><li><p>循环因子：一个单词有（wordLen * 26）个相邻节点，因为可以<strong>一次</strong>变成（wordLen * 26）个其他单词，所以循环因子有两个，因此有两层嵌套循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; wordLen; j++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> k = <span class="string">&#x27;a&#x27;</span>; k &lt;= <span class="string">&#x27;z&#x27;</span>; k++) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造相邻节点：因为队列里元素为字符串，所以要构造新字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">charArray[j] = k;</span><br><span class="line">String nextWord = String.valueOf(charArray);</span><br></pre></td></tr></table></figure></li></ol><p><strong>完整代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先将 wordList 放到哈希表里，便于判断某个单词是否在 wordList 里</span></span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        <span class="keyword">if</span> (wordSet.size() == <span class="number">0</span> || !wordSet.contains(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        wordSet.remove(beginWord);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 图的广度优先遍历，必须使用的队列和表示是否访问过的 visited （数组，哈希表）</span></span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(beginWord);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        visited.add(beginWord);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wordLen = beginWord.length();</span><br><span class="line">        <span class="comment">// 包含起点，因此初始化的时候步数为 1</span></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> currentSize = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currentSize; i++) &#123;</span><br><span class="line">                <span class="comment">// 依次遍历当前队列中的单词</span></span><br><span class="line">                String word = queue.poll();</span><br><span class="line">                <span class="keyword">char</span>[] charArray = word.toCharArray();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(word.equals(endWord))&#123;</span><br><span class="line">                    <span class="keyword">return</span> step;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 修改每一个字符</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; wordLen; j++) &#123;</span><br><span class="line">                    <span class="comment">// 一轮以后应该重置，否则结果不正确</span></span><br><span class="line">                    <span class="keyword">char</span> originChar = charArray[j];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> k = <span class="string">&#x27;a&#x27;</span>; k &lt;= <span class="string">&#x27;z&#x27;</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (k == originChar) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        charArray[j] = k;</span><br><span class="line">                        String nextWord = String.valueOf(charArray);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (wordSet.contains(nextWord) &amp;&amp; !visited.contains(nextWord)) &#123;</span><br><span class="line">                            queue.add(nextWord);</span><br><span class="line">                            <span class="comment">// 注意：添加到队列以后，必须马上标记为已经访问</span></span><br><span class="line">                            visited.add(nextWord);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 恢复</span></span><br><span class="line">                    charArray[j] = originChar;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode129. 求根到叶子节点数字之和</title>
      <link href="post/d6166674.html"/>
      <url>post/d6166674.html</url>
      
        <content type="html"><![CDATA[<p><strong>使用<a href="./%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E5%92%8C%E9%80%92%E5%BD%92%E7%9A%84%E5%8C%BA%E5%88%AB.md">递归分析模板</a>将会十分清晰</strong></p><p><strong>转载自：<a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/solution/er-cha-shu-zhong-de-zui-da-lu-jing-he-by-leetcode-/">Leetcode题解（力扣官方题解），略有增删</a></strong></p><a id="more"></a><ol><li><p>状态：树节点(变化量)，用root表示；recursion(root)表示以 <code>root</code> 为根节点的到叶子结点的数字之和。但是本题有点特殊，因为一个节点的值是和它的父亲节点是有关系的，所以还需要传递一个父亲节点的值，即递归函数的参数有2个<code>recursion(root, i)</code>。<strong>但是一般来说是有几个状态函数参数就有几个的</strong></p></li><li><p>递归终止条件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空节点的数字和为0</span></span><br><span class="line"><span class="keyword">if</span> (root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><strong>用动态规划的角度表示最小子问题为：<code>dp[null] = 0</code></strong></p></li><li><p>状态转移方程(可能涉及到多次if条件判断)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个节点的值是和它的父亲节点是有关系的</span></span><br><span class="line"><span class="keyword">int</span> res = i * <span class="number">10</span> + root.val;</span><br><span class="line"><span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)<span class="comment">//2、节点为叶子节点</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line"><span class="keyword">return</span> DFS(root.left, res) + DFS(root.right, res);<span class="comment">//3、节点为非叶子节点</span></span><br></pre></td></tr></table></figure><p><strong>用动态规划的角度表示转移方程为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = i * <span class="number">10</span> + root.val;</span><br><span class="line"><span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">dp[root] = res;  </span><br><span class="line">&#125;</span><br><span class="line">dp[root] = dp[root.left] + dp[root.right];</span><br></pre></td></tr></table></figure></li><li><p>返回最终状态：return recursion(n, 0)；</p><p><strong>用动态规划的角度表示最终返回值为：<code>return dp[root]</code></strong></p></li></ol><p><strong>完整代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DFS(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">DFS</span><span class="params">(TreeNode root, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//1、节点为空</span></span><br><span class="line">        <span class="keyword">int</span> res = i * <span class="number">10</span> + root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)<span class="comment">//2、节点为叶子节点</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">return</span> DFS(root.left, res) + DFS(root.right, res);<span class="comment">//3、节点为非叶子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode124. 二叉树中的最大路径和</title>
      <link href="post/7545a421.html"/>
      <url>post/7545a421.html</url>
      
        <content type="html"><![CDATA[<p><strong>使用<a href="./%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E5%92%8C%E9%80%92%E5%BD%92%E7%9A%84%E5%8C%BA%E5%88%AB.md">递归分析模板</a>将会十分清晰</strong></p><p><strong>转载自：<a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/solution/er-cha-shu-zhong-de-zui-da-lu-jing-he-by-leetcode-/">Leetcode题解（力扣官方题解），略有增删</a></strong></p><a id="more"></a><ol><li><p>状态：树节点(变化量)，用root表示；recursion(root)表示以 <code>root</code> 为根节点的最大路径和</p></li><li><p>递归终止条件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空节点是没有值的</span></span><br><span class="line"><span class="keyword">if</span> (node == null) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用动态规划的角度表示最小子问题为：</strong><code>dp[null] = 0</code></p></li><li><p>状态转移方程(可能涉及到多次if条件判断)：</p><p>非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和（对于叶节点而言，最大贡献值等于节点值）。    </p><p>例如，考虑如下二叉树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">-10</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>叶节点 9、15、7 的最大贡献值分别为 9、15、7。</p><p>得到叶节点的最大贡献值之后，再计算非叶节点的最大贡献值。节点 2020 的最大贡献值等于 20 + max(15, 7) = 3520 + max(15,7) = 35，节点 -10−10 的最大贡献值等于 -10 + max(9, 35) = 25 − 10 + max(9, 35) = 25。</p><p>上述计算过程是递归的过程，因此，对根节点调用函数 <code>maxGain</code>，即可得到每个节点的最大贡献值。</p><p>根据函数 <code>maxGain</code> 得到每个节点的最大贡献值之后，如何得到二叉树的最大路径和？对于二叉树中的一个节点，该节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值，如果子节点的最大贡献值为正，则计入该节点的最大路径和，否则不计入该节点的最大路径和。维护一个全局变量 <code>maxSum </code>存储最大路径和，在递归过程中更新 <code>maxSum </code>的值，最后得到的 <code>maxSum </code>的值即为二叉树中的最大路径和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归计算左右子节点的最大贡献值</span></span><br><span class="line"><span class="comment">// 只有在最大贡献值大于 0 时，才会选取对应子节点</span></span><br><span class="line"><span class="keyword">int</span> leftGain = max(maxGain(node-&gt;left), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> rightGain = max(maxGain(node-&gt;right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span></span><br><span class="line"><span class="keyword">int</span> priceNewpath = node-&gt;val + leftGain + rightGain;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新答案</span></span><br><span class="line">maxSum = max(maxSum, priceNewpath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回节点的最大贡献值</span></span><br><span class="line"><span class="keyword">return</span> node-&gt;val + max(leftGain, rightGain);</span><br></pre></td></tr></table></figure><p><strong>用动态规划的角度表示转移方程为：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[root] = root.val + Math.max(dp[root.left], dp[root.right])</span><br></pre></td></tr></table></figure></li><li><p>返回最终状态：return recursion(root)；</p><p><strong>用动态规划的角度表示最终返回值为：<code>return dp[root]</code></strong></p></li></ol><p><strong>完整代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> maxSum = INT_MIN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxGain</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归计算左右子节点的最大贡献值</span></span><br><span class="line">        <span class="comment">// 只有在最大贡献值大于 0 时，才会选取对应子节点</span></span><br><span class="line">        <span class="keyword">int</span> leftGain = max(maxGain(node-&gt;left), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> rightGain = max(maxGain(node-&gt;right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">int</span> priceNewpath = node-&gt;val + leftGain + rightGain;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新答案</span></span><br><span class="line">        maxSum = max(maxSum, priceNewpath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">return</span> node-&gt;val + max(leftGain, rightGain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        maxGain(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode113. 路径总和 II</title>
      <link href="post/a876447c.html"/>
      <url>post/a876447c.html</url>
      
        <content type="html"><![CDATA[<p><strong>使用<a href="./%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E5%92%8C%E9%80%92%E5%BD%92%E7%9A%84%E5%8C%BA%E5%88%AB.md">递归分析模板</a>将会十分清晰</strong></p><p><strong>与<a href="./Leetcode113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II.md">Leetcode112-路径总和</a>的思想一致</strong></p><p><strong>转载自：<a href="https://leetcode-cn.com/problems/path-sum-ii/solution/hui-su-suan-fa-shen-du-you-xian-bian-li-zhuang-tai/">Leetcode题解（liweiwei1419），略有增删</a></strong></p><a id="more"></a><ol><li><p>状态：树节点(变化量)，用root表示；recursion(root)表示从 <code>root</code> 到叶子节点是否存在路径和为 <code>sum</code> 的路径 ，并且把路径打印出来</p></li><li><p>递归终止条件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若为空节点，不管sum为多少，表示无路可走，自然什么也不干</span></span><br><span class="line"><span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">  <span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>状态转移方程(可能涉及到多次if条件判断)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">path.push_back(root-&gt;val);</span><br><span class="line"><span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span> &amp;&amp; root-&gt;val == sum)&#123;</span><br><span class="line">  res.push_back(path);</span><br><span class="line">&#125;</span><br><span class="line">dfs(root-&gt;left, sum - root-&gt;val, path);</span><br><span class="line">dfs(root-&gt;right, sum - root-&gt;val, path);</span><br></pre></td></tr></table></figure><p><strong>用动态规划的角度表示转移方程为：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">path.push_back(root-&gt;val);</span><br><span class="line"><span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span> &amp;&amp; root-&gt;val == sum)&#123;</span><br><span class="line">  res.push_back(path);</span><br><span class="line">&#125;</span><br><span class="line">dp[root] = dp[root.left][sum - root.val] = 对path进行操作 </span><br><span class="line">+ dp[root.right][sum - root.val] = 对path进行操作</span><br></pre></td></tr></table></figure></li><li><p>返回最终状态：return res；</p></li></ol><p><strong>完整代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span> &amp;&amp; root-&gt;val == sum)&#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, sum - root-&gt;val, path);</span><br><span class="line">        dfs(root-&gt;right, sum - root-&gt;val, path);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        dfs(root, sum, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode112. 路径总和</title>
      <link href="post/78212637.html"/>
      <url>post/78212637.html</url>
      
        <content type="html"><![CDATA[<p><strong>使用<a href="./%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E5%92%8C%E9%80%92%E5%BD%92%E7%9A%84%E5%8C%BA%E5%88%AB.md">递归分析模板</a>将会十分清晰</strong></p><p><strong>转载自：<a href="https://leetcode-cn.com/problems/path-sum/solution/jian-dan-di-gui-bi-xu-miao-dong-by-sweetiee-2/">Leetcode题解（sweetiee），略有增删</a></strong></p><a id="more"></a><ol><li><p>状态：树节点(变化量)，用root表示；recursion(root)表示从 <code>root</code> 到叶子节点是否存在路径和为 <code>sum</code> 的路径 <code>hasPathSum(root, sum)</code></p></li><li><p>递归终止条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若为空节点，不管sum为多少都是false</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用动态规划的角度表示最小子问题为：<code>dp[0][sum] = false</code></strong></p></li><li><p>状态转移方程(可能涉及到多次if条件判断)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 到达叶子节点时，递归终止，判断 sum 是否符合条件。</span></span><br><span class="line"><span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> root.val == sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归地判断root节点的左孩子和右孩子。</span></span><br><span class="line"><span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br></pre></td></tr></table></figure><p><strong>用动态规划的角度表示转移方程为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">  dp[root][sum] = root.val == sum;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  dp[root][sum] = dp[root.left][sum - root.val] || dp[root.right][sum - root.val]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回最终状态：return recursion(root, sum)；</p><p><strong>用动态规划的角度表示最终返回值为：<code>return dp[n][sum]</code></strong></p></li></ol><p><strong>完整代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到达叶子节点时，递归终止，判断 sum 是否符合条件。</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.val == sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归地判断root节点的左孩子和右孩子。</span></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode111. 二叉树的最小深度</title>
      <link href="post/1be921e7.html"/>
      <url>post/1be921e7.html</url>
      
        <content type="html"><![CDATA[<p><strong>使用<a href="./%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E5%92%8C%E9%80%92%E5%BD%92%E7%9A%84%E5%8C%BA%E5%88%AB.md">递归分析模板</a>将会十分清晰</strong></p><p><strong>转载自：<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/li-jie-zhe-dao-ti-de-jie-shu-tiao-jian-by-user7208/">Leetcode题解（王小二），略有增删</a></strong></p><a id="more"></a><h4 id="一、DFS"><a href="#一、DFS" class="headerlink" title="一、DFS"></a>一、DFS</h4><ol><li><p>状态：树节点(变化量)，用root表示；recursion(root)表示以该root节点为根节点的树的最小深度</p></li><li><p>递归终止条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>状态转移方程(可能涉及到多次if条件判断)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.左孩子和有孩子都为空的情况，说明到达了叶子节点，直接返回1即可</span></span><br><span class="line"><span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">//2.如果左孩子和由孩子其中一个为空，那么需要返回比较大的那个孩子的深度        </span></span><br><span class="line"><span class="keyword">int</span> m1 = minDepth(root.left);</span><br><span class="line"><span class="keyword">int</span> m2 = minDepth(root.right);</span><br><span class="line"><span class="comment">//这里其中一个节点为空，说明m1和m2有一个必然为0，所以可以返回m1 + m2 + 1;</span></span><br><span class="line"><span class="keyword">if</span>(root.left == <span class="keyword">null</span> || root.right == <span class="keyword">null</span>) <span class="keyword">return</span> m1 + m2 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.最后一种情况，也就是左右孩子都不为空，返回最小深度+1即可</span></span><br><span class="line"><span class="keyword">return</span> Math.min(m1,m2) + <span class="number">1</span>; </span><br></pre></td></tr></table></figure><p><strong>用动态规划角度来看的转移方程为</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dp[root.left] == <span class="keyword">null</span> &amp;&amp; dp[root.right] == <span class="keyword">null</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(dp[root.left] == <span class="keyword">null</span> || dp[root.right] == <span class="keyword">null</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> dp[root.left] + dp[root.right] + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Math.min(dp[root.left], dp[root.right]) + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回最终状态：return recursion(n)；</p></li></ol><p><strong>完整代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//这道题递归条件里分为三种情况</span></span><br><span class="line">        <span class="comment">//1.左孩子和有孩子都为空的情况，说明到达了叶子节点，直接返回1即可</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//2.如果左孩子和由孩子其中一个为空，那么需要返回比较大的那个孩子的深度        </span></span><br><span class="line">        <span class="keyword">int</span> m1 = minDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> m2 = minDepth(root.right);</span><br><span class="line">        <span class="comment">//这里其中一个节点为空，说明m1和m2有一个必然为0，所以可以返回m1 + m2 + 1;</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> || root.right == <span class="keyword">null</span>) <span class="keyword">return</span> m1 + m2 + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.最后一种情况，也就是左右孩子都不为空，返回最小深度+1即可</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(m1,m2) + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、BFS"><a href="#二、BFS" class="headerlink" title="二、BFS"></a>二、BFS</h4><p>最小高度其实和层数是有关的，记录层数恰好符合BFS的思路，详情参考<a href="./BFS%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF.md">BFS问题模板</a>。其实如果按照层序遍历来解题的话，从上下到，从左到右，直到有一个节点的左右孩子都是空就返回这个高度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//bfs。一层一层的遍历，直到有一个节点的左右孩子都是空就返回这个高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//为空就返回0</span></span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">1</span>;<span class="comment">//初始高度为1</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> count = queue.size();<span class="comment">//每一层遍历，有双子节点都为空就返回当前高度</span></span><br><span class="line">            <span class="keyword">while</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode cur = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> height;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            height++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> 树 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode105. 从前序与中序遍历序列构造二叉树</title>
      <link href="post/5df2e57e.html"/>
      <url>post/5df2e57e.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/dong-hua-yan-shi-105-cong-qian-xu-yu-zhong-xu-bian/">Leetcode题解（王尼玛），略有增删</a></strong></p><a id="more"></a><h3 id="一、让我们尝试用递归模板来解题"><a href="#一、让我们尝试用递归模板来解题" class="headerlink" title="一、让我们尝试用递归模板来解题"></a>一、让我们尝试用递归模板来解题</h3><p><a href="./%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E5%92%8C%E9%80%92%E5%BD%92%E7%9A%84%E5%8C%BA%E5%88%AB.md">分而治之和递归的区别</a></p><ol><li>状态：前序和中序数组的下标(变化量)，用pre_i和in_i表示，<strong>recursion(pre_i, in_i)表示构造以in_i为根节点的二叉树</strong>。只不过需要注意的是<strong>分而治之</strong>的思想一般用两个变量<code>left和right</code>来表示数组下标，并且递归函数需要有原数组作为参数，所以递归函数更改为**(int[] preorder, int p_start, int p_end, int[] inorder, int i_start, int i_end)**</li><li>递归终止条件：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p_start &gt; p_end) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>状态转移方程：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在中序遍历中找到根节点的位置</span></span><br><span class="line"><span class="keyword">int</span> i_root_index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = i_start; i &lt; i_end; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root_val == inorder[i]) &#123;</span><br><span class="line">    i_root_index = i;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> leftNum = i_root_index - i_start;</span><br><span class="line"><span class="comment">//==============上面的代码只是为了找到中序数组中的根节点下标，你需要明白用前序和中序构造二叉树的原理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归的构造左子树</span></span><br><span class="line">root.left = buildTreeHelper(preorder, p_start + <span class="number">1</span>, p_start + leftNum + <span class="number">1</span>, inorder, i_start,</span><br><span class="line">                            i_root_index);</span><br><span class="line"><span class="comment">//递归的构造右子树</span></span><br><span class="line">root.right = buildTreeHelper(preorder, p_start + leftNum + <span class="number">1</span>, p_end, inorder, i_root_index + <span class="number">1</span>, i_end);</span><br></pre></td></tr></table></figure><p><strong>如果按照动态规划角度来看</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[root] = dp[root.left] + dp[root.right]</span><br></pre></td></tr></table></figure><ol start="4"><li>返回最终状态：<code>return recursion(root);</code></li></ol><p><strong>完整代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buildTreeHelper(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTreeHelper</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> p_start, <span class="keyword">int</span> p_end, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> i_start, <span class="keyword">int</span> i_end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// preorder 为空，直接返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (p_start &gt; p_end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root_val = preorder[p_start];</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(root_val);</span><br><span class="line">    <span class="comment">//在中序遍历中找到根节点的位置</span></span><br><span class="line">    <span class="keyword">int</span> i_root_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = i_start; i &lt; i_end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root_val == inorder[i]) &#123;</span><br><span class="line">            i_root_index = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftNum = i_root_index - i_start;</span><br><span class="line">    <span class="comment">//递归的构造左子树</span></span><br><span class="line">    root.left = buildTreeHelper(preorder, p_start + <span class="number">1</span>, p_start + leftNum + <span class="number">1</span>, inorder, i_start, i_root_index);</span><br><span class="line">    <span class="comment">//递归的构造右子树</span></span><br><span class="line">    root.right = buildTreeHelper(preorder, p_start + leftNum + <span class="number">1</span>, p_end, inorder, i_root_index + <span class="number">1</span>, i_end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 分而治之 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode110. 平衡二叉树</title>
      <link href="post/3b0aff9b.html"/>
      <url>post/3b0aff9b.html</url>
      
        <content type="html"><![CDATA[<p><strong>使用<a href="./%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E5%92%8C%E9%80%92%E5%BD%92%E7%9A%84%E5%8C%BA%E5%88%AB.md">递归分析模板</a>将会十分清晰</strong></p><a id="more"></a><ol><li>状态：树节点(变化量)，用root表示；recursion(root)表示以该root节点为根节点的树是否是平衡二叉树</li><li>递归终止条件：空节点就是一个平衡二叉树</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>状态转移方程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.abs(depth(root.left) - depth(root.right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br></pre></td></tr></table></figure><p><strong>如果用动态规划的转移方程来写，大概是</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[root] = Math.abs(depth(root.left) - depth(root.right)) &lt;= <span class="number">1</span> &amp;&amp; dp[root.left] &amp;&amp; dp[root.right]</span><br></pre></td></tr></table></figure><ol start="4"><li>返回最终状态：return recursion(root);</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(depth(root.left) - depth(root.right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(depth(root.left), depth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>计算树高度的depth()函数其实也按照这种模板</strong></p><ol><li>状态：树节点(变化量)，用root表示；recursion(root)表示以该root节点为根节点的树的高度</li><li>递归终止条件：空节点的树高为0</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>状态转移方程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max(depth(root.left), depth(root.right)) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>如果用动态规划的转移方程来写，大概是</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[root] = max(dp[root.left] + dp[root.right]) + <span class="number">1</span> </span><br></pre></td></tr></table></figure><ol start="4"><li>返回最终状态：return depth(root);</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode108. 将有序数组转换为二叉搜索树</title>
      <link href="post/4372fe16.html"/>
      <url>post/4372fe16.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/solution/jian-dan-di-gui-bi-xu-miao-dong-by-sweetiee/">Leetcode题解（sweetiee），略有增删</a></strong></p><a id="more"></a><h3 id="一、题目分析"><a href="#一、题目分析" class="headerlink" title="一、题目分析"></a>一、题目分析</h3><p><strong>题意</strong>：根据升序数组，恢复一棵高度平衡的BST🌲。</p><p><strong>分析</strong>：BST的中序遍历是升序的，因此本题等同于根据中序遍历的序列恢复二叉搜索树。因此我们可以以升序序列中的任一个元素作为根节点，以该元素左边的升序序列构建左子树，以该元素右边的升序序列构建右子树，这样得到的树就是一棵二叉搜索树啦～ 又因为本题要求高度平衡，因此我们需要选择升序序列的中间元素作为根节点奥～</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt; hi) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 以升序数组的中间元素作为根节点 root。</span></span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">      <span class="comment">// 治：root.left和root.right本身就是一种治，把分和总联系在一起</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        <span class="comment">// 分</span></span><br><span class="line">        root.left = dfs(nums, lo, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = dfs(nums, mid + <span class="number">1</span>, hi); </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、让我们尝试用递归模板来解题"><a href="#二、让我们尝试用递归模板来解题" class="headerlink" title="二、让我们尝试用递归模板来解题"></a>二、让我们尝试用递归模板来解题</h3><p><a href="./%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E5%92%8C%E9%80%92%E5%BD%92%E7%9A%84%E5%8C%BA%E5%88%AB.md">分而治之和递归的区别</a></p><ol><li><p>状态：有序数组的下标(变化量)，用<code>i</code>来表示。<code>recursion(i)</code>表示以nums[i]为根节点，以有序数组和平衡二叉树的关系，这个i处于数组的正中间。怎么表示出正中间这个性质呢？那么<code>i</code>就需要用<code>(left + right) / 2</code>来表示了，那么递归函数的参数就应该有两个，一个代表left，一个代表right，但是本质就只是表示一个数组下标。最后因为原数组也要写进函数参数里，所以最后的形式为<code>recursion(nums, left, right)</code></p></li><li><p>递归终止条件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里着重说一下本题的递归终止条件</span></span><br><span class="line"><span class="comment">// 依照”最容易想到“原则，也许会把left=right当成最容易想到的情况，则代码为</span></span><br><span class="line"><span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(nums[left]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但是上面的情况违背了&quot;最小子问题的值始终固定&quot;原则</span></span><br><span class="line"><span class="comment">// 因为随着left或者right的值不同，与之对应的nums[left]值也不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以另一个容易想到的情况为left&gt;right，这是一种不可能情况，则代码为</span></span><br><span class="line"><span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">  <span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这种情况依据&quot;最小子问题的值始终固定&quot;原则，无论left和right是什么值，返回的都是固定值null，所以符合条件</span></span><br></pre></td></tr></table></figure></li><li><p>状态转移方程(通过对状态的循环多次，有几个状态就有几层循环，对立相反的状态只需写两行代码即可，不需要循环)：</p><p><strong>如果按照动态规划角度来看，可以看做recursion(root) = root.val + recursion(root.left) + recursion(root.right)</strong></p><p><strong>是不是和dp[i] = 1 + dp[i - 1] + dp[i + 1]很类似呀</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以升序数组的中间元素作为根节点 root。</span></span><br><span class="line"><span class="keyword">int</span> mid = left + (right - lift) / <span class="number">2</span>;</span><br><span class="line">TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line"></span><br><span class="line">root.left = recursion(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">root.right = recursion(nums, mid + <span class="number">1</span>, right); </span><br></pre></td></tr></table></figure></li><li><p>返回最终状态：<strong>return root;</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 分而治之 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分而治之和递归的区别</title>
      <link href="post/25823055.html"/>
      <url>post/25823055.html</url>
      
        <content type="html"><![CDATA[<p><strong>详见<a href="E:\code\hexo-site\blog\source_posts\Leetcode98-验证二叉搜索树.md">Leetcode98-验证二叉搜索树</a></strong></p><a id="more"></a><p><strong>这里再顺便简要说明一下递归函数的编写技巧，纯属个人做题时的总结，非严谨推导</strong></p><p><strong>随着做题的深入会不断更新~</strong></p><p><u><strong>首先要明确起递归和动态规划之间的联系，递归是<code>自顶向下</code>，动态规划是<code>自底向上</code>，对于我个人来说，用<a href="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%9D%E6%83%B3.md">动态规划模板</a>格式化分析一道题要来的容易些，所以使用动态规划类比，构建其和递归之间的联系</strong></u></p><h3 id="一-动态规划N步骤——-gt-递归N步骤"><a href="#一-动态规划N步骤——-gt-递归N步骤" class="headerlink" title="一. 动态规划N步骤——&gt;递归N步骤"></a>一. 动态规划N步骤——&gt;递归N步骤</h3><p><strong>我们仿照动态规划里的说法对递归步骤进行定义</strong></p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E5%92%8C%E9%80%92%E5%BD%92%E7%9A%84%E5%8C%BA%E5%88%AB/1598355721878.png" alt="1598355721878"></p><ol><li>在使用递归的题目里，也涉及到状态，这个状态也能用<strong>变化量</strong>来确定，至于<strong>对立相反量</strong>目前还没看到</li><li>如果动态规划里<strong>状态即下标</strong>，那么在递归方法里<strong>状态就是递归函数某一次的递归</strong>；动态规划的<strong>dp数组下标</strong>在递归里用<strong>函数参数</strong>替代，比如动态规划里的**<code>dp[5]</code><strong>在递归里用</strong><code>recursion(5)</code>**表示</li><li>递归函数的意义和dp数组的意义的设置方法是相同的。比如<code>dp[2]</code>为前两个数组元素的和，那么<code>recursion(2)</code>也代表前两个数组元素的和。这个要具体问题具体分析，可能会很复杂</li><li>这里需注意下，因为dp就是一个数组，最多根据状态个数拓展数组维度dp[a] [b] [c] [d]….；而根据函数的特性，可以有很多个参数，所以参数可以五花八门，其中跟具体题目逻辑无关的参数有<ol><li>原始数组(如果题目给出的话)</li><li>根据题目分析出的状态变量</li><li>…</li></ol></li></ol><hr><p><img src= "/img/loading.gif" data-lazy-src="./%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E5%92%8C%E9%80%92%E5%BD%92%E7%9A%84%E5%8C%BA%E5%88%AB/1598357229731.png" alt="1598357229731"></p><ol><li><strong>递归里的<code>递归结束条件</code> == 动态规划里的<code>最小子问题</code>**，递归的递归结束条件也符合</strong>最容易想到**原则</li><li><strong>动态规划里最小子问题必须要结合dp数组的含义才能确定，那么递归结束条件也必须要结合递归函数的定义才能确定</strong>，我们举一个例子<a href="./Leetcode108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.md">Leetcode108. 将有序数组转换为二叉搜索树</a>，具体分析请移步对应题解页</li></ol><hr><p><img src= "/img/loading.gif" data-lazy-src="./%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E5%92%8C%E9%80%92%E5%BD%92%E7%9A%84%E5%8C%BA%E5%88%AB/1598358225901.png" alt="1598358225901"></p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E5%92%8C%E9%80%92%E5%BD%92%E7%9A%84%E5%8C%BA%E5%88%AB/1598358613077.png" alt="1598358613077"></p><ol><li>状态转移方程在动态规划里的体现就是<strong>dp数组下标变化</strong>，在递归里的体现就是<strong>递归函数参数的变化</strong></li><li>至于说动态规划里的有多少个状态就有多少次嵌套循环，在递归里貌似没有这种说法，TODO</li><li>递归函数的参数也一般都是+1，-1或者具体问题具体分析</li></ol><hr><p><img src= "/img/loading.gif" data-lazy-src="./%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E5%92%8C%E9%80%92%E5%BD%92%E7%9A%84%E5%8C%BA%E5%88%AB/1598358563835.png" alt="1598358563835"></p><ol><li><p>递归最后返回的也是另一个极端</p></li><li><p>递归的返回值是以函数的形式表示的，比如说<code>return recursion(n)</code>，它处在函数最外层；而动态规划的返回值是以值的形式返回的，比如说<code>return dp[n]</code>，他处在函数内层的最下面；这是特指有返回值的情况，若无返回值，比如说输出一组最xxx的路径等返回值为<code>void</code>类型数据的情况时，两者无区别，都是把最终的值保存在一个第三方的容器里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 函数内层的最下面</span></span><br><span class="line">  <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数最外层</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> variable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特例，两者无区别</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 函数内层的最下面</span></span><br><span class="line">  path.push_back(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数最外层</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  path.push_back(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、最后给出一个公式"><a href="#二、最后给出一个公式" class="headerlink" title="二、最后给出一个公式"></a>二、最后给出一个公式</h3></li><li><p>状态：A ，B，C….，N个状态的组合对应着什么值</p></li><li><p>递归终止条件：dp[i] = … 或者 dp[i] [0] = …..或者其他</p><p><strong>用动态规划的角度表示最小子问题为：</strong></p></li><li><p>状态转移方程(可能涉及到多次if条件判断)：recursion(i) = recursion(i + 1) + x 或其他</p><p><strong>用动态规划的角度表示转移方程为：</strong></p></li><li><p>返回最终状态：return recursion(n)；或者其他</p><p><strong>用动态规划的角度表示最终返回值为：</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分而治之 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode1079. 活字印刷</title>
      <link href="post/ff8df00a.html"/>
      <url>post/ff8df00a.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/letter-tile-possibilities/solution/cdian-xing-de-dfshui-su-zhong-dian-shi-qu-zhong-by/">Leetcode题解（congwang357），略有增删</a></strong></p><a id="more"></a><p><strong>请严格按照<a href="./Leetcode46-%E5%85%A8%E6%8E%92%E5%88%97.md">回溯模板</a>所提到的格式分析与编写代码，因为此题和Leetcode面试题-08-08几乎一样，所以完整的格式分析请参照该题</strong></p><p>**这道题和<a href="./Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-08-08-%E6%9C%89%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88.md">Leetcode面试题-08-08-有重复字符串的排列组合</a>**一样，涉及到重复字母的排序，但是这道题的回溯结束条件不一样：这道题没有回溯结束条件，因为不涉及到结果字符串长度必须和输入字符串长度保持一致</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;visit)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 原本在这一块是有回溯结束条件的</span></span><br><span class="line">      <span class="comment">// ........</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (str[i] == str[i - <span class="number">1</span>] &amp;&amp; (visit[i - <span class="number">1</span>] == <span class="literal">false</span>)))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!visit[i])&#123;</span><br><span class="line">                visit[i] = <span class="literal">true</span>;</span><br><span class="line">                ans++;</span><br><span class="line">                dfs(str, visit);</span><br><span class="line">                visit[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTilePossibilities</span><span class="params">(<span class="built_in">string</span> tiles)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(tiles.size(), <span class="number">0</span>);</span><br><span class="line">        sort(tiles.begin(), tiles.end());</span><br><span class="line">        dfs(tiles, visit);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode面试题 08.08. 有重复字符串的排列组合</title>
      <link href="post/6289af.html"/>
      <url>post/6289af.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/permutation-ii-lcci/solution/c-qu-zhong-dfsyi-dong-by-shang-xian-yue-4/">Leetcode题解（上弦月），略有增删</a></strong></p><a id="more"></a><p>如果这道题目字符串中没有相同字母那直接回溯就可以得到正确答案，但假设出现了相同字母。如 “abb” ，直接回溯会<strong>将两个b看作不同的字母</strong>，两个b的相对位置不同也会被纳入解中，（b1ab2、b2ab1)</p><p>我们怎样去重？ 其实很简单，前面的b不需要考虑后面的b怎么排列（因为后面的b属于一个新的排列），遍历到后面的b时，若前面的b处于未访问的状态，这种状态就是重复状态，因为前面的b已经将以b开头的所有子排列添加到了答案中，不需要第二个以b开头的子排列</p><p><strong>请严格按照<a href="./Leetcode46-%E5%85%A8%E6%8E%92%E5%88%97.md">回溯模板</a>所提到的格式分析与编写代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 路径：记录在 track 中</span></span><br><span class="line">    <span class="comment">// 选择列表：根据输出里包含字母来判断，选择列表是一个字母串.</span></span><br><span class="line">  <span class="comment">// 因为题干提供的本身就是字母，我们直接拿题干当选择列表即可。</span></span><br><span class="line">    <span class="comment">// 结束条件：路径长度等于源字符串长度</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;result, <span class="built_in">string</span> s, <span class="built_in">string</span> track, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(track.size() == s.size())&#123;</span><br><span class="line">            result.push_back(track);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">          <span class="comment">// 剪枝</span></span><br><span class="line">            <span class="keyword">if</span>((i &gt; <span class="number">0</span> &amp;&amp; s[i] == s[i<span class="number">-1</span>] &amp;&amp; !visited[i<span class="number">-1</span>]) || visited[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            track.push_back(s[i]);</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            backtrack(result, s, track, visited);</span><br><span class="line">            track.pop_back();</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> track = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(s.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">      <span class="comment">// 这里先排序，把相同的字母都放在相邻的位置</span></span><br><span class="line">        sort(s.begin(),s.end());</span><br><span class="line">        backtrack(result, s, track, visited);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注：回溯体内的循环可以简化成</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">  <span class="comment">// 剪枝</span></span><br><span class="line">  <span class="keyword">if</span>((i &gt; <span class="number">0</span> &amp;&amp; s[i] == s[i-<span class="number">1</span>] &amp;&amp; !visited[i-<span class="number">1</span>]) || visited[i])&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  visited[i] = <span class="keyword">true</span>;</span><br><span class="line">  backtrack(result, s, track + s[i], visited);</span><br><span class="line">  visited[i] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode17. 电话号码的字母组合</title>
      <link href="post/c3a78369.html"/>
      <url>post/c3a78369.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/leetcode-17-letter-combinations-of-a-phone-number-/">Leetcode题解（乌鲁木齐001号程序员），略有增删</a></strong></p><a id="more"></a><p><strong>请严格按照<a href="./Leetcode46-%E5%85%A8%E6%8E%92%E5%88%97.md">回溯模板</a>所提到的格式分析与编写代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> string letterMap[<span class="number">10</span>] = &#123;</span><br><span class="line">      <span class="string">&quot; &quot;</span>,    <span class="comment">// 0</span></span><br><span class="line">      <span class="string">&quot;&quot;</span>,     <span class="comment">// 1</span></span><br><span class="line">      <span class="string">&quot;abc&quot;</span>,  <span class="comment">// 2</span></span><br><span class="line">      <span class="string">&quot;def&quot;</span>,  <span class="comment">// 3</span></span><br><span class="line">      <span class="string">&quot;ghi&quot;</span>,  <span class="comment">// 4</span></span><br><span class="line">      <span class="string">&quot;jkl&quot;</span>,  <span class="comment">// 5</span></span><br><span class="line">      <span class="string">&quot;mno&quot;</span>,  <span class="comment">// 6</span></span><br><span class="line">      <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">      <span class="string">&quot;tuv&quot;</span>,  <span class="comment">// 8</span></span><br><span class="line">      <span class="string">&quot;wxyz&quot;</span>  <span class="comment">// 9</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  vector&lt;string&gt; res;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 路径：记录在 s 中</span></span><br><span class="line"><span class="comment">// 选择列表：根据输出里包含字母来判断，选择列表是一个字母串.</span></span><br><span class="line">  <span class="comment">// 观察题干字母串的产生是由digits和index和letterMap共同构成的</span></span><br><span class="line">  <span class="comment">// digits和index确定下标，letterMap+下标就能获得选择列表(字母串)</span></span><br><span class="line"><span class="comment">// 结束条件：已经处理的digits长度个字符</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">findCombination</span><span class="params">(<span class="keyword">const</span> string &amp;digits, <span class="keyword">int</span> index, <span class="keyword">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 满足结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (index == digits.size()) &#123;</span><br><span class="line">      res.push_back(s);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c = digits[index];</span><br><span class="line">    string letters = letterMap[c - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    <span class="comment">// 循环遍历选择列表并且做选择</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letters.size(); i++) &#123;</span><br><span class="line">      findCombination(digits, index + <span class="number">1</span>, s + letters[i]);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 这里如果按照标准写法的话</span></span><br><span class="line">      <span class="comment">// 做选择</span></span><br><span class="line">      <span class="comment">// index = index + 1;</span></span><br><span class="line">      <span class="comment">// 进入下一层决策树</span></span><br><span class="line">      <span class="comment">// findCombination(digits, index, s + letters[i]);</span></span><br><span class="line">      <span class="comment">// 取消选择</span></span><br><span class="line">      <span class="comment">// index = index - 1;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    res.clear();</span><br><span class="line">    <span class="keyword">if</span> (digits == <span class="string">&quot;&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    findCombination(digits, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode130. 被围绕的区域</title>
      <link href="post/61220aa7.html"/>
      <url>post/61220aa7.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://mp.weixin.qq.com/s/K_oV5JWYpBo9cWTHz6e35Q">公众号（labuladong），略有增删</a></strong></p><a id="more"></a><p>注意哦，必须是完全被围的<code>O</code>才能被换成<code>X</code>，也就是说边角上的<code>O</code>一定不会被围，进一步，与边角上的<code>O</code>相连的<code>O</code>也不会被<code>X</code>围四面，也不会被替换：</p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/1598318710325.png" alt="1598318710325"></p><p>这个问题本身使用DFS解决的，也可以用 Union-Find 算法解决，虽然实现复杂一些，甚至效率也略低，但这是使用 Union-Find 算法的通用思想，值得一学。</p><p><strong>你可以把那些不需要被替换的O看成一个拥有独门绝技的门派，它们有一个共同祖师爷叫dummy，这些O和dummy互相连通，而那些需要被替换的O与dummy不连通</strong>。</p><p>这就是 Union-Find 的核心思路，明白这个图，就很容易看懂代码了：</p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/1598318765620.png" alt="1598318765620"></p><p>首先要解决的是，根据我们的实现，Union-Find 底层用的是一维数组，构造函数需要传入这个数组的大小，而题目给的是一个二维棋盘。</p><p>这个很简单，二维坐标<code>(x,y)</code>可以转换成<code>x * n + y</code>这个数（<code>m</code>是棋盘的行数，<code>n</code>是棋盘的列数）。敲黑板，<strong>这是将二维坐标映射到一维的常用技巧</strong>。</p><p>其次，我们之前描述的「祖师爷」是虚构的，需要给他老人家留个位置。索引<code>[0.. m*n-1]</code>都是棋盘内坐标的一维映射，那就让这个虚拟的<code>dummy</code>节点占据索引<code>m*n</code>好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = board.length;</span><br><span class="line">    <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// 给 dummy 留一个额外位置</span></span><br><span class="line">    UF uf = <span class="keyword">new</span> UF(m * n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> dummy = m * n;</span><br><span class="line">    <span class="comment">// 将首列和末列的 O 与 dummy 连通</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            uf.union(i * n, dummy);</span><br><span class="line">        <span class="keyword">if</span> (board[i][n - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            uf.union(i * n + n - <span class="number">1</span>, dummy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将首行和末行的 O 与 dummy 连通</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            uf.union(j, dummy);</span><br><span class="line">        <span class="keyword">if</span> (board[m - <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            uf.union(n * (m - <span class="number">1</span>) + j, dummy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方向数组 d 是上下左右搜索的常用手法</span></span><br><span class="line">    <span class="keyword">int</span>[][] d = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) </span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                <span class="comment">// 将此 O 与上下左右的 O 连通</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + d[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y = j + d[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (board[x][y] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                        uf.union(x * n + y, i * n + j);</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="comment">// 所有不和 dummy 连通的 O，都要被替换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) </span><br><span class="line">            <span class="keyword">if</span> (!uf.connected(dummy, i * n + j))</span><br><span class="line">                board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很长，其实就是刚才的思路实现，只有和边界<code>O</code>相连的<code>O</code>才具有和<code>dummy</code>的连通性，他们不会被替换。</p><p>说实话，Union-Find 算法解决这个简单的问题有点杀鸡用牛刀，它可以解决更复杂，更具有技巧性的问题，<strong>主要思路是适时增加虚拟节点，想办法让元素「分门别类」，建立动态连通关系</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode990. 等式方程的可满足性</title>
      <link href="post/818f3af5.html"/>
      <url>post/818f3af5.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://mp.weixin.qq.com/s/K_oV5JWYpBo9cWTHz6e35Q">公众号（labuladong），略有增删</a></strong></p><a id="more"></a><p>动态连通性其实就是一种等价关系，具有「自反性」「传递性」和「对称性」，其实<code>==</code>关系也是一种等价关系，具有这些性质。所以这个问题用 Union-Find 算法就很自然。</p><p>核心思想是，<strong>将equations中的算式根据==和!=分成两部分，先处理==算式，使得他们通过相等关系各自勾结成门派；然后处理!=算式，检查不等关系是否破坏了相等关系的连通性</strong>。</p><p><strong>UF的构造函数详见<a href="./%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.md">并查集算法详解</a></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equationsPossible</span><span class="params">(String[] equations)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 26 个英文字母</span></span><br><span class="line">    UF uf = <span class="keyword">new</span> UF(<span class="number">26</span>);</span><br><span class="line">    <span class="comment">// 先让相等的字母形成连通分量</span></span><br><span class="line">    <span class="keyword">for</span> (String eq : equations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eq.charAt(<span class="number">1</span>) == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> x = eq.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">char</span> y = eq.charAt(<span class="number">3</span>);</span><br><span class="line">            uf.union(x - <span class="string">&#x27;a&#x27;</span>, y - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查不等关系是否打破相等关系的连通性</span></span><br><span class="line">    <span class="keyword">for</span> (String eq : equations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eq.charAt(<span class="number">1</span>) == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> x = eq.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">char</span> y = eq.charAt(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">// 如果相等关系成立，就是逻辑冲突</span></span><br><span class="line">            <span class="keyword">if</span> (uf.connected(x - <span class="string">&#x27;a&#x27;</span>, y - <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集算法详解</title>
      <link href="post/72b86188.html"/>
      <url>post/72b86188.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://mp.weixin.qq.com/s/gUwLfi25TYamq8AJVIopfA">公众号（labuladong），略有增删</a></strong></p><a id="more"></a><h3 id="1-问题介绍"><a href="#1-问题介绍" class="headerlink" title="1. 问题介绍"></a>1. 问题介绍</h3><p>简单说，动态连通性其实可以抽象成给一幅图连线。比如下面这幅图，总共有 10 个节点，他们互不相连，分别用 0~9 标记：</p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/1598316100817.png" alt="1598316100817"></p><p>现在我们的 并查(Union-Find) 算法主要需要实现这两个 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 将 p 和 q 连接 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>;</span><br><span class="line">    <span class="comment">/* 判断 p 和 q 是否连通 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>;</span><br><span class="line">    <span class="comment">/* 返回图中有多少个连通分量 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里所说的「连通」是一种等价关系，也就是说具有如下三个性质：</p><p><strong>1、自反性</strong>：节点<code>p</code>和<code>p</code>是连通的。</p><p><strong>2、对称性</strong>：如果节点<code>p</code>和<code>q</code>连通，那么<code>q</code>和<code>p</code>也连通。</p><p><strong>3、传递性</strong>：如果节点<code>p</code>和<code>q</code>连通，<code>q</code>和<code>r</code>连通，那么<code>p</code>和<code>r</code>也连通。</p><p>比如说之前那幅图，0～9 任意两个<strong>不同</strong>的点都不连通，调用<code>connected</code>都会返回 false，连通分量为 10 个。</p><p>如果现在调用<code>union(0, 1)</code>，那么 0 和 1 被连通，连通分量降为 9 个。</p><p>再调用<code>union(1, 2)</code>，这时 0,1,2 都被连通，调用<code>connected(0, 2)</code>也会返回 true，连通分量变为 8 个。</p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/1598316277172.png" alt="1598316277172"></p><p>判断这种「等价关系」非常实用，比如说编译器判断同一个变量的不同引用，比如社交网络中的朋友圈计算等等。</p><h3 id="2-基本思路"><a href="#2-基本思路" class="headerlink" title="2. 基本思路"></a>2. 基本思路</h3><p>那么用什么模型来表示这幅图的连通状态呢？用什么数据结构来实现代码呢？</p><p>我们使用森林（若干棵树）来表示图的动态连通性，用数组来具体实现这个森林。怎么用森林来表示连通性呢？我们设定树的每个节点有一个指针指向其父节点，如果是根节点的话，这个指针指向自己。</p><p>比如说刚才那幅 10 个节点的图，一开始的时候没有相互连通，就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录连通分量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">// 节点 x 的节点是 parent[x]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造函数，n 为图的节点总数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一开始互不连通</span></span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        <span class="comment">// 父节点指针初始指向自己</span></span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 其他函数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="./%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/1598316412430.png" alt="1598316412430"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">    <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将两棵树合并为一棵</span></span><br><span class="line">    parent[rootP] = rootQ;</span><br><span class="line">    <span class="comment">// parent[rootQ] = rootP 也一样</span></span><br><span class="line">    count--; <span class="comment">// 两个分量合二为一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回某个节点 x 的根节点 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">    <span class="keyword">while</span> (parent[x] != x)</span><br><span class="line">        x = parent[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回当前的连通分量个数 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="./%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/1598316436910.png" alt="1598316436910"></p><p><strong>这样，如果节点p和q连通的话，它们一定拥有相同的根节点</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">    <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="./%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/1598316465079.png" alt="1598316465079"></p><p>至此，Union-Find 算法就基本完成了。是不是很神奇？竟然可以这样使用数组来模拟出一个森林，如此巧妙的解决这个比较复杂的问题！</p><p>那么这个算法的复杂度是多少呢？我们发现，主要 API<code>connected</code>和<code>union</code>中的复杂度都是<code>find</code>函数造成的，所以说它们的复杂度和<code>find</code>一样。</p><p><code>find</code>主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的高度。我们可能习惯性地认为树的高度就是<code>logN</code>，但这并不一定。<strong>logN的高度只存在于平衡二叉树，对于一般的树可能出现极端不平衡的情况，使得「树」几乎退化成「链表」，树的高度最坏情况下可能变成N。</strong></p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/1598316495512.png" alt="1598316495512"></p><p>所以说上面这种解法，<code>find</code>,<code>union</code>,<code>connected</code>的时间复杂度都是 O(N)。这个复杂度很不理想的，你想图论解决的都是诸如社交网络这样数据规模巨大的问题，对于<code>union</code>和<code>connected</code>的调用非常频繁，每次调用需要线性时间完全不可忍受。</p><h3 id="3-平衡性优化"><a href="#3-平衡性优化" class="headerlink" title="3. 平衡性优化"></a>3. 平衡性优化</h3><p>我们要知道哪种情况下可能出现不平衡现象，关键在于<code>union</code>过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">    <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将两棵树合并为一棵</span></span><br><span class="line">    parent[rootP] = rootQ;</span><br><span class="line">    <span class="comment">// parent[rootQ] = rootP 也可以</span></span><br><span class="line">    count--; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一开始就是简单粗暴的把<code>p</code>所在的树接到<code>q</code>所在的树的根节点下面，那么这里就可能出现「头重脚轻」的不平衡状况，比如下面这种局面：</p><p><img src= "/img/loading.gif" data-lazy-src="./%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/1598316569229.png" alt="1598316569229"></p><p>长此以往，树可能生长得很不平衡。<strong>我们其实是希望，小一些的树接到大一些的树下面，这样就能避免头重脚轻，更平衡一些</strong>。解决方法是额外使用一个<code>size</code>数组，记录每棵树包含的节点数，我们不妨称为「重量」：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="comment">// 新增一个数组记录树的“重量”</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// 最初每棵树只有一个节点</span></span><br><span class="line">        <span class="comment">// 重量应该初始化 1</span></span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 其他函数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如说<code>size[3] = 5</code>表示，以节点<code>3</code>为根的那棵树，总共有<code>5</code>个节点。这样我们可以修改一下<code>union</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">    <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小树接到大树下面，较平衡</span></span><br><span class="line">    <span class="keyword">if</span> (size[rootP] &gt; size[rootQ]) &#123;</span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        size[rootP] += size[rootQ];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        size[rootQ] += size[rootP];</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，通过比较树的重量，就可以保证树的生长相对平衡，树的高度大致在<code>logN</code>这个数量级，极大提升执行效率。</p><p>此时，<code>find</code>,<code>union</code>,<code>connected</code>的时间复杂度都下降为 O(logN)，即便数据规模上亿，所需时间也非常少。</p><h3 id="4-路径压缩-如果想不明白可以不用，问题也不大"><a href="#4-路径压缩-如果想不明白可以不用，问题也不大" class="headerlink" title="4. 路径压缩(如果想不明白可以不用，问题也不大)"></a>4. 路径压缩(如果想不明白可以不用，问题也不大)</h3><p>这步优化特别简单，所以非常巧妙。我们能不能进一步压缩每棵树的高度，使树高始终保持为常数？</p><p>这样<code>find</code>就能以 O(1) 的时间找到某一节点的根节点，相应的，<code>connected</code>和<code>union</code>复杂度都下降为 O(1)。</p><p>要做到这一点，非常简单，只需要在<code>find</code>中加一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">        <span class="comment">// 进行路径压缩</span></span><br><span class="line">        parent[x] = parent[parent[x]];</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动图演示移步<a href="https://mp.weixin.qq.com/s/gUwLfi25TYamq8AJVIopfA">公众号（labuladong）</a></strong></p><h3 id="5-最后总结"><a href="#5-最后总结" class="headerlink" title="5. 最后总结"></a>5. 最后总结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 连通分量个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">// 存储一棵树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="comment">// 记录树的“重量”</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 小树接到大树下面，较平衡</span></span><br><span class="line">        <span class="keyword">if</span> (size[rootP] &gt; size[rootQ]) &#123;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            size[rootP] += size[rootQ];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootP] = rootQ;</span><br><span class="line">            size[rootQ] += size[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里的find是采用了路径压缩之后的写法</span></span><br><span class="line">  <span class="comment">// 如果不采用路径压缩则可以直接写一行代码：x = parent[x];</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">            <span class="comment">// 进行路径压缩</span></span><br><span class="line">            parent[x] = parent[parent[x]];</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Union-Find 算法的复杂度可以这样分析：构造函数初始化数据结构需要 O(N) 的时间和空间复杂度；连通两个节点<code>union</code>、判断两个节点的连通性<code>connected</code>、计算连通分量<code>count</code>所需的时间复杂度均为 O(1)。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS问题模板</title>
      <link href="post/cf0d82d5.html"/>
      <url>post/cf0d82d5.html</url>
      
        <content type="html"><![CDATA[<p><strong>无向图中两个顶点之间的<code>最短路径</code>的长度，可以通过广度优先遍历得到；</strong></p><p>BFS问题模板详见<a href="./Leetcode102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.md">Leetcode102-二叉树的层序遍历</a></p><a id="more"></a><p>做图类型的题目一般会使用到DFS和BFS两个算法</p><p>而在采用这两种算法思想之前最关键的一步就是<strong>建图</strong>，这能更好地对我们使用<strong>BFS模板</strong>进行结构性的引导。而关于建图有一种简易方法：<strong>寻找相邻点</strong>，这里的相邻点不仅仅是<strong>显性相邻</strong>的点，比如二维数组的上下左右点。还有可能是<strong>隐形相邻</strong>，或者说是<strong>抽象</strong>的相邻点，比如</p><ol><li><strong>时钟里的时针，0刻度和1刻度就是相邻的点，而0刻度和11刻度也是相邻的点。从0刻度开始顺时针<code>走一步</code>就成了1刻度，逆时针<code>走一步</code>就成了11刻度</strong></li><li><strong>字母变化，英文一共有26个英文字母，每个字母都能通过<code>一次变化</code>从而变成其他25个英文字母，也就是说其他25个英文字母和该字母相邻</strong></li><li>二维数组里一个节点的<strong>九宫格</strong>区域，每次通过改变数组下标来改变对应位置元素的值</li><li>….</li></ol><p>发现了什么规律没，我们在这里特别强调<strong>变化一次等价于相邻</strong></p><p><img src= "/img/loading.gif" data-lazy-src="./BFS%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF/1598496999368.png" alt="1598496999368"></p><hr><p><img src= "/img/loading.gif" data-lazy-src="./BFS%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF/1598441372359.png" alt="1598441372359"></p><hr><p><strong>我们特别注意这里的红色线条，这里的交叉线条表示A能一次变成G,H,E；H也能一次变成A,G,E；G能一次变成A,H，E能一次变成A,H</strong>，区别于比如B点一次只能变成A，J点一次只能变成H</p><p><img src= "/img/loading.gif" data-lazy-src="./BFS%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF/1598441702999.png" alt="1598441702999"></p><p>只要有<strong>逻辑上</strong>的<strong>变化一次</strong>，我们就可以建议一幅图，等建立完一副图后就可以套BFS或者DFS的模板了</p><p><strong>需要注意的几点</strong></p><ol><li><p><strong>图各个节点的元素会被题目的条件所限制，就比如说字母的变化，一个单词本来可以一次变成其他25个单词的，但是如果题目限定只能变成某几个字母，那么就按照题目给的限定条件来</strong></p></li><li><p>建图有两种形式，一种是题目给你建好了图，即给了<strong>边与点的关系</strong>，这种情况下需要在对图进行<strong>队列</strong>操作之前通过循环等操作把所有的点与边连接起来。这时的建图方法可以使用<strong>邻接表或者邻接矩阵</strong>形式；或者就直接给你一个<strong>二维数组</strong>，这本身就直接给了你一个构造好了的邻接矩阵</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如给了4个点，3条边，然后连接成下图所示的图</span></span><br><span class="line">n = <span class="number">4</span>, edges = [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        |</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">       / \</span><br><span class="line">      <span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure><p>下面给出一个一般性的建图代码，使用<strong>邻接矩阵</strong>方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*建立图关系，在每个节点的list中存储相连节点*/</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  graph.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">  graph.get(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);<span class="comment">/*添加相邻节点*/</span></span><br><span class="line">  graph.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==============================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*循环条件当然是经典的不空判断*/</span></span><br><span class="line"><span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">  ....</span><br><span class="line">  <span class="comment">/*获取节点相邻节点集合*/</span></span><br><span class="line">  List&lt;Integer&gt; neighbors = graph.get(cur);</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是，这时的元素入队操作queue.push就没了构造节点这一目的了</strong></p><p><strong>做题时如果有使用节点出入度的性质来辅助的话的模板</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*建立图关系，在每个节点的list中存储相连节点*/</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  map.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*建立各个节点的出度表*/</span></span><br><span class="line"><span class="keyword">int</span>[] degree = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">  degree[edge[<span class="number">0</span>]]++;</span><br><span class="line">  degree[edge[<span class="number">1</span>]]++;<span class="comment">/*出度++*/</span></span><br><span class="line"></span><br><span class="line">  map.get(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);<span class="comment">/*添加相邻节点*/</span></span><br><span class="line">  map.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*建立队列*/</span></span><br><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">/*把所有出度为1的节点，也就是叶子节点入队*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (degree[i] == <span class="number">1</span>) queue.offer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*循环条件当然是经典的不空判断*/</span></span><br><span class="line"><span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">  ....</span><br><span class="line">  <span class="comment">/*获取节点相邻节点集合*/</span></span><br><span class="line">  List&lt;Integer&gt; neighbors = map.get(cur);</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>另一种是一边在遍历题目所给元素，一边构造出来的，这个构造关键点就在**元素的入队queue.push(当前节点)**，详情参照<a href="./Leetcode102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.md">Leetcode102-二叉树的层序遍历</a></p></li></ol><p><img src= "/img/loading.gif" data-lazy-src="./BFS%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF/1598442758641.png" alt="1598442758641"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯问题模板</title>
      <link href="post/df63e4a3.html"/>
      <url>post/df63e4a3.html</url>
      
        <content type="html"><![CDATA[<p>回溯问题模板详见<a href="./Leetcode46-%E5%85%A8%E6%8E%92%E5%88%97.md">Leetcode46-全排列</a></p><a id="more"></a><p><strong>回溯算法一般在一维数组，二维数组，树类型的题目里用的比较多</strong></p><h4 id="一、一维数组"><a href="#一、一维数组" class="headerlink" title="一、一维数组"></a>一、一维数组</h4><ul><li>一维数组有一种典型题型，就是<strong>求各种各样的子序列集合</strong>，比如经典的<a href="https://leetcode-cn.com/problems/permutations-ii/">排列组合</a>，<a href="https://leetcode-cn.com/problems/increasing-subsequences/">递增子序列</a>等，反正就是对一维数组里的数按照题意东平西凑，凑出一大堆结果，这里就涉及到一个很关键的条件：元素是否能<strong>重复</strong></li><li>针对元素是否能重复Leetcode对全排列还有两道不同的题，分别是<a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a>，<a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></li></ul><p><strong>有重复元素的问题在于：假设出现了相同字母，如 “abb” ，当进行全排列直接回溯会将两个b看作不同的字母，两个b的相对位置不同也会被纳入解中，（b1ab2、b2ab1)，但其实两者结果都是bab</strong></p><p><strong>这里对元素是否能重复来讨论下一般性的解题套路</strong></p><p><strong>根据Leetcode上的题解，针对元素能重复使用的情况有两种解题模板，而区分两者的条件是：<code>元素下标是否需要被考虑</code></strong></p><ul><li><p>元素下标不需要被考虑：如<a href="https://leetcode-cn.com/problems/permutation-ii-lcci/">面试题 08.08. 有重复字符串的排列组合</a></p><ul><li><p>step1：一开始就对原数组进行排序，把排序好的数组放入回溯函数中去</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(s.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="comment">// 这里先排序，把相同的字母都放在相邻的位置</span></span><br><span class="line">sort(s.begin(),s.end());</span><br></pre></td></tr></table></figure></li><li><p>step2：在遍历选择列表时写上如下代码，同时使用<code>visited</code>数组防止元素重复遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剪枝</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>((i &gt; <span class="number">0</span> &amp;&amp; s[i] == s[i<span class="number">-1</span>] &amp;&amp; !visited[i<span class="number">-1</span>]) || visited[i])&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>元素下标需要被考虑：如<a href="./Leetcode491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.md">Leetcode491. 递增子序列</a>，这里着重说一下这种情况，什么叫元素下标需要被考虑的，比如Leetcode491. 递增子序列这道题，如果按照前一种方法需要事先对原数组进行排序，那么<strong>原来的数组下标将会被打乱</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于原数组[2, 4, 3, 2]</span></span><br><span class="line"><span class="comment">// 对应的递增子序列有[2, 4], [2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若一开始就把原数组排序后成[2, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// 那么对应的递增子序列有[2, 2, 3], [2, 2, 4], [2, 3, 4], [2, 3], [2, 4], [3, 4], [2, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 很明显两者的结果截然不同</span></span><br></pre></td></tr></table></figure><p>所以这种情况不能对原数组进行排序，那么解决的模板为</p><ul><li><p>使用<code>set</code>来辅助，<code>set</code>集合的作用为：如果 <code>set </code>中已经有与 <code>nums[i] </code>相同的值了，说明加上<code>nums[i]</code> 后的所有可能的递增序列之前已经被搜过一遍了，因此停止继续搜索。</p></li><li><p>不能像前一种方法在对选择列表遍历的时候数组起点开始遍历，而是要从当前元素接下去的元素下标开始遍历，并且不需要<code>visited</code>数组的辅助，因为前面的元素都不会被遍历到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> idx, List&lt;Integer&gt; track)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 初始化去重的set集合</span></span><br><span class="line">  Set&lt;Integer&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  <span class="comment">// 从传入下标参数的下一个元素开始对选择列表进行遍历</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = idx + <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">set</span>.contains(nums[i])) &#123; </span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">set</span>.add(nums[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//=======对重复元素的处理关键在上半部分===========</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt;= nums[idx]) &#123;</span><br><span class="line">      track.add(nums[i]);</span><br><span class="line">      dfs(nums, i, track);</span><br><span class="line">      track.remove(track.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划思想</title>
      <link href="post/8a9d5576.html"/>
      <url>post/8a9d5576.html</url>
      
        <content type="html"><![CDATA[<p><strong>内容详见<a href="./Leetcode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.md">Leetcode121-买卖股票的最佳时机</a></strong></p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode682. 棒球比赛</title>
      <link href="post/278fc5d.html"/>
      <url>post/278fc5d.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/daily-temperatures/solution/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/">Leetcode题解（程序员吴师兄），略有增删</a></strong></p><p><strong>栈模板<a href="./%E4%BD%BF%E7%94%A8%E6%A0%88%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3.md">使用栈解题思想</a></strong></p><a id="more"></a><p>先从使用栈的几个前提条件出发：</p><ol><li>是否涉及到<strong>比较</strong>：没有</li><li>是否涉及到<strong>延迟比较</strong>：涉及到保存分数</li></ol><p><strong>注：该题是使用栈的一个经典题型，但不是使用单调栈，两者区别详见栈解题思想</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calPoints</span><span class="params">(String[] ops)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String op : ops) &#123;</span><br><span class="line">            <span class="keyword">if</span> (op.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> top = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> newtop = top + stack.peek();</span><br><span class="line">                stack.push(top);</span><br><span class="line">                stack.push(newtop);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">&quot;C&quot;</span>)) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">&quot;D&quot;</span>)) &#123;</span><br><span class="line">                stack.push(<span class="number">2</span> * stack.peek());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(Integer.valueOf(op));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> score : stack) ans += score;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode496. 下一个更大元素 I</title>
      <link href="post/71ca1465.html"/>
      <url>post/71ca1465.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/next-greater-element-i/solution/dan-diao-zhan-jie-jue-next-greater-number-yi-lei-w/">Leetcode题解（labuladong），略有增删</a></strong></p><p><strong>栈模板<a href="./%E4%BD%BF%E7%94%A8%E6%A0%88%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3.md">使用栈解题思想</a></strong></p><a id="more"></a><p>先从使用栈的几个前提条件出发：</p><ol><li>是否涉及到<strong>比较</strong>：题目为下一个更大的元素，当然涉及比较</li><li>是否涉及到<strong>延迟比较</strong>：下一个比当前元素大的元素可能隔着十万八千里，但是是存在的，所以需要保存，这就涉及了延迟比较</li></ol><p><strong>但是这道题有点特殊，需要从后往前遍历，但是除此之外完全符合模板解题思路</strong></p><p>这个问题可以这样抽象思考：把数组的元素想象成并列站立的人，元素大小想象成人的身高。这些人面对你站成一列，如何求元素「2」的 Next Greater Number 呢？很简单，如果能够看到元素「2」，那么他后面可见的第一个人就是「2」的 Next Greater Number，因为比「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案。</p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I/1598276393675.png" alt="1598276393675"></p><p>for 循环要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈，其实是正着出栈。while 循环是把两个“高个”元素之间的元素排除，因为他们的存在没有意义，前面挡着个“更高”的元素，所以他们不可能被作为后续进来的元素的 Next Great Number 了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size())</span></span>; <span class="comment">// 存放答案的数组</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 倒着往栈里放</span></span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() &lt;= nums[i]) &#123; <span class="comment">// 判定个子高矮</span></span><br><span class="line">            s.pop(); <span class="comment">// 矮个起开，反正也被挡着了。。。</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = s.empty() ? <span class="number">-1</span> : s.top(); <span class="comment">// 这个元素身后的第一个高个</span></span><br><span class="line">        s.push(nums[i]); <span class="comment">// 进队，接受之后的身高判定吧！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode84. 柱状图中最大的矩形</title>
      <link href="post/25209534.html"/>
      <url>post/25209534.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/xiang-jie-dan-diao-zhan-bi-xu-miao-dong-by-sweetie/">Leetcode题解（Sweetiee），略有增删</a></strong></p><p><strong>栈模板<a href="./%E4%BD%BF%E7%94%A8%E6%A0%88%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3.md">使用栈解题思想</a></strong></p><a id="more"></a><p>先从使用栈的几个前提条件出发：</p><ol><li>是否涉及到<strong>比较</strong>：比较长和宽乘积的大小</li><li>是否涉及到<strong>延迟比较</strong>：对于当前柱子的高度，之后可能出现更高的柱子，导致长和宽都增大从而使可勾勒面积增大，所以需要<strong>保存</strong>当前柱子高度以便之后运算比较</li></ol><p>思路分析<br>我们可以遍历每根柱子，以当前柱子 i 的高度作为矩形的高，那么矩形的宽度边界即为向左找到第一个高度小于当前柱体 i 的柱体，向右找到第一个高度小于当前柱体 i 的柱体。</p><p>对于每个柱子我们都如上计算一遍以当前柱子作为高的矩形面积，最终比较出最大的矩形面积即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跟归纳总结过的使用栈当辅助结构的模思想板高度一致</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里为了代码简便，在柱体数组的头和尾加了两个高度为 0 的柱体。</span></span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[heights.length + <span class="number">2</span>];</span><br><span class="line">      <span class="comment">// 这里的技巧是给数组左右两端添值为0，以进行普遍操作，就像给链表添加头节点一样</span></span><br><span class="line">        System.arraycopy(heights, <span class="number">0</span>, tmp, <span class="number">1</span>, heights.length); </span><br><span class="line">        </span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前数组元素值大于或等于栈顶元素值</span></span><br><span class="line">          <span class="comment">// 说明柱子高度还在增加，从而勾勒的面积可能继续增大，所以不进入while处理</span></span><br><span class="line">          <span class="comment">// 以此说明while循环的其中一个条件是当前处理元素小于栈顶元素</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; tmp[i] &lt; tmp[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> h = tmp[stack.pop()];</span><br><span class="line">                area = Math.max(area, (i - stack.peek() - <span class="number">1</span>) * h);   </span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode145. 二叉树的后序遍历</title>
      <link href="post/6ac94452.html"/>
      <url>post/6ac94452.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/er-cha-shu-de-qian-xu-bian-li-by-leetcode/">Leetcode题解（力扣 (LeetCode)），略有增删</a></strong></p><p><strong>栈模板<a href="./%E4%BD%BF%E7%94%A8%E6%A0%88%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3.md">使用栈解题思想</a></strong></p><a id="more"></a><p>先从使用栈的几个前提条件出发：</p><ol><li>是否涉及到<strong>比较</strong>：没涉及到比较</li><li>是否涉及到<strong>延迟比较</strong>：后序遍历的核心就是<strong>左右中</strong>，先遍历左节点——&gt;再遍历右节点——&gt;再遍历根节点，那么根节点就需要被保存，这就是<strong>延迟</strong>。虽然题目中没有涉及到比较操作，但是涉及到延迟，也可以使用栈来辅助实现中序遍历</li></ol><p><strong>我们根据栈模板中提到的<code>必写代码</code>来分析如下答案</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; output = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">      TreeNode node = stack.pollLast();</span><br><span class="line">      <span class="comment">// 注意这里是addFirst，即在数组首部插入元素</span></span><br><span class="line">      output.addFirst(node.val);</span><br><span class="line">      <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.add(node.left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.add(node.right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode144. 二叉树的前序遍历</title>
      <link href="post/3ac91e5e.html"/>
      <url>post/3ac91e5e.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/er-cha-shu-de-qian-xu-bian-li-by-leetcode/">Leetcode题解（力扣 (LeetCode)），略有增删</a></strong></p><p><strong>栈模板<a href="./%E4%BD%BF%E7%94%A8%E6%A0%88%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3.md">使用栈解题思想</a></strong></p><a id="more"></a><p>先从使用栈的几个前提条件出发：</p><ol><li>是否涉及到<strong>比较</strong>：没涉及到比较</li><li>是否涉及到<strong>延迟比较</strong>：前序遍历的核心就是<strong>中左右</strong>，先遍历根节点——&gt;再遍历左节点——&gt;再遍历右节点，那么右节点就需要被保存，这就是<strong>延迟</strong>。虽然题目中没有涉及到比较操作，但是涉及到延迟，也可以使用栈来辅助实现中序遍历</li></ol><p><strong>我们根据栈模板中提到的<code>必写代码</code>来分析如下答案</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; output = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.add(root);</span><br><span class="line">    <span class="comment">// 1. 必写代码之二：对栈的判空，不管是用while还是if</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// 2. 必写代码之四：出栈</span></span><br><span class="line">      TreeNode node = stack.pollLast();</span><br><span class="line">      <span class="comment">// 3. 必写代码之三：取出栈顶元素</span></span><br><span class="line">      output.add(node.val);</span><br><span class="line">      <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 4. 必写代码之五：入栈</span></span><br><span class="line">        stack.add(node.right);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 5. 必写代码之一：对原始数据的循环遍历，对于树这种数据结构来说访问左右子节点就是在循环</span></span><br><span class="line">      <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.add(node.left);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode739. 每日温度</title>
      <link href="post/6fc19b5d.html"/>
      <url>post/6fc19b5d.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/daily-temperatures/solution/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/">Leetcode题解（程序员吴师兄），略有增删</a></strong></p><p><strong>栈模板<a href="./%E4%BD%BF%E7%94%A8%E6%A0%88%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3.md">使用栈解题思想</a></strong></p><a id="more"></a><p>先从使用栈的几个前提条件出发：</p><ol><li>是否涉及到<strong>比较</strong>：要想观测到更高的气温，只有比较之后才会得出温度是否升高不是吗？</li><li>是否涉及到<strong>延迟比较</strong>：我要找到一个比当天温度高的天，但如果某天之后若干天温度都比当天低的话无法计算等待的天数了，所以我要一直等，直到之后的某一天温度比当天温度高，这个过程就涉及到了<strong>保存当天温度直到出现温度更高的那一天</strong></li></ol><p>下面来一个个进行具体的解释。</p><p>对于输入 73，它需要 经过一天 才能等到温度的升高，也就是在第二天的时候，温度升高到 74 ，所以对应的结果是 1。</p><p>对于输入 74，它需要 经过一天 才能等到温度的升高，也就是在第三天的时候，温度升高到 75 ，所以对应的结果是 1。</p><p>对于输入 75，它经过 1 天后发现温度是 71，没有超过它，继续等，一直 等了四天，在第七天才等到温度的升高，温度升高到 76 ，所以对应的结果是 4 。</p><p>对于输入 71，它经过 1 天后发现温度是 69，没有超过它，继续等，一直 等了两天，在第六天才等到温度的升高，温度升高到 72 ，所以对应的结果是 2 。</p><p>对于输入 69，它 经过一天 后发现温度是 72，已经超过它，所以对应的结果是 1 。</p><p>对于输入 72，它 经过一天 后发现温度是 76，已经超过它，所以对应的结果是 1 。</p><p>对于输入 76，后续 没有温度 可以超过它，所以对应的结果是 0 。</p><p>对于输入 73，后续 没有温度 可以超过它，所以对应的结果是 0 。</p><p>好了，理解了题意我们来思考如何求解。</p><p>第一个想法就是针对每个温度值 向后进行依次搜索 ，找到比当前温度更高的值，这是最容易想到的办法。</p><p>其原理是从左到右除了最后一个数其他所有的数都遍历一次，最后一个数据对应的结果肯定是 0，就不需要计算。</p><p>遍历的时候，每个数都去向后数，直到找到比它大的数，数的次数就是对应输出的值。</p><p><strong>满足了延迟比较的特点，所以使用栈来辅助解题</strong></p><p><strong>我们根据栈模板中提到的<code>必写代码</code>来分析如下答案</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = temperatures.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">      <span class="comment">// 1. 必写代码之一：对原始数据的循环遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temperatures.size(); ++i) &#123;</span><br><span class="line">          <span class="comment">// 2. 必写代码之二：对栈的判空，不管是用while还是if</span></span><br><span class="line">           <span class="comment">// 对元素数据里的每一个元素都进行栈操作</span></span><br><span class="line">          <span class="comment">// 获取栈顶元素之后的具体比较逻辑</span></span><br><span class="line">          <span class="comment">// 3. 必写代码之三：获取栈顶元素，并且进行逻辑处理</span></span><br><span class="line">            <span class="keyword">while</span> (!st.empty() &amp;&amp; temperatures[i] &gt; temperatures[st.top()]) &#123;</span><br><span class="line">              <span class="comment">// 4. 必写代码之四：出栈</span></span><br><span class="line">                <span class="keyword">auto</span> t = st.top(); st.pop();</span><br><span class="line">                res[t] = i - t;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 5. 必写代码之五：入栈</span></span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode94. 二叉树的中序遍历</title>
      <link href="post/6bf51b4b.html"/>
      <url>post/6bf51b4b.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode/">Leetcode题解（力扣 (LeetCode)），略有增删</a></strong></p><p><strong>栈模板<a href="./%E4%BD%BF%E7%94%A8%E6%A0%88%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3.md">使用栈解题思想</a></strong></p><a id="more"></a><h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List &lt; Integer &gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List &lt; Integer &gt; res = <span class="keyword">new</span> ArrayList &lt; &gt; ();</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List &lt; Integer &gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                helper(root.left, res);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                helper(root.right, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二：基于栈的遍历"><a href="#方法二：基于栈的遍历" class="headerlink" title="方法二：基于栈的遍历"></a>方法二：基于栈的遍历</h4><p>先从使用栈的几个前提条件出发：</p><ol><li>是否涉及到<strong>比较</strong>：没涉及到比较</li><li>是否涉及到<strong>延迟比较</strong>：中序遍历的核心就是<strong>左中右</strong>，先遍历左节点——&gt;再遍历根节点——&gt;再遍历右节点，那么中间的根节点就需要被保存，这就是<strong>延迟</strong>。虽然题目中没有涉及到比较操作，但是涉及到延迟，也可以使用栈来辅助实现中序遍历</li></ol><p><strong>我们根据栈模板中提到的<code>必写代码</code>来分析如下答案</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List &lt; Integer &gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List &lt; Integer &gt; res = <span class="keyword">new</span> ArrayList &lt; &gt; ();</span><br><span class="line">        Stack &lt; TreeNode &gt; stack = <span class="keyword">new</span> Stack &lt; &gt; ();</span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">      <span class="comment">// 1. 必写代码之一：对原始数据的循环遍历</span></span><br><span class="line">      <span class="comment">// 2. 必写代码之二：对栈的判空，不管是用while还是if</span></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">          <span class="comment">// 外层如果是&quot;或&quot;循环，在内层需要分别对各个&quot;或条件&quot;进行单独判断</span></span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 3. 必写代码之五：入栈</span></span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 4. 必写代码之三：出栈</span></span><br><span class="line">            curr = stack.pop();</span><br><span class="line">          <span class="comment">// 其实这行代码本质上就是获取栈顶元素</span></span><br><span class="line">            res.add(curr.val);</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 栈 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode42. 接雨水</title>
      <link href="post/62c1d573.html"/>
      <url>post/62c1d573.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/">Leetcode题解（windliang），略有增删</a></strong></p><p><strong>栈模板<a href="./%E4%BD%BF%E7%94%A8%E6%A0%88%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3.md">使用栈解题思想</a></strong></p><a id="more"></a><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/1598237950112.png" alt="1598237950112"></p><p><strong>先从使用栈的几个前提条件出发：</strong></p><ol><li>是否涉及到<strong>比较</strong>：雨水容积 = (左侧墙和右侧墙相减) * 两堵墙之间的距离，相减就是比较</li><li>是否涉及到<strong>延迟比较</strong>：肯定先计算中间那两堵墙之间的容积再计算外侧两堵墙之间的容积，而根据数组从左到右的遍历顺序，最外侧左侧的那堵墙肯定是先被进行处理和判断的，但是他要和最后遍历到的右侧墙进行比较。所以涉及到延迟比较</li></ol><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/1598238133246.png" alt="1598238133246"></p><p><strong>满足了延迟比较的特点，所以使用栈来辅助结题</strong></p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/1598237911772.png" alt="1598237911772"></p><p>说到栈，我们肯定会想到括号匹配了。我们仔细观察蓝色的部分，可以和括号匹配类比下。每次匹配出一对括号（找到对应的一堵墙），就计算这两堵墙中的水。</p><p><strong>我们用栈保存每堵墙。</strong></p><p>当遍历墙的高度的时候，如果当前高度小于栈顶的墙高度，说明这里会有积水，我们将墙的高度的下标入栈。</p><p>如果当前高度大于栈顶的墙的高度，说明之前的积水到这里停下，我们可以计算下有多少积水了。计算完，就把当前的墙继续入栈，作为新的积水的墙。</p><p>总体的原则就是</p><ol><li>当前高度小于等于栈顶高度，入栈，指针后移。</li><li>当前高度大于栈顶高度，出栈，计算出当前墙和栈顶的墙之间水的多少。然后计算当前的高度和新栈的高度的关系，重复第 2 步。直到当前墙的高度不大于栈顶高度或者栈空，然后把当前墙入栈，指针后移。</li></ol><p>我们看具体的例子。</p><ul><li><p>首先将 height [ 0 ] 入栈。然后 current 指向的高度大于栈顶高度，所以把栈顶 height [ 0 ] 出栈，然后栈空了，再把 height [ 1 ] 入栈。current 后移</p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/884e05b8d73985e777bbfdec92c9b77db5bd6305df67c15c321fa725c4a9198b-image.png" alt="image.png"></p></li><li><p>然后 <code>current</code> 指向的高度小于栈顶高度，<code>height [ 2 ]</code> 入栈，<code>current</code> 后移。</p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/a0c201eb77c2f3640968ddea89a1907c6ac831f07577c4526ee8c049191b42df-image.png" alt="image.png"></p></li><li><p>然后 current 指向的高度大于栈顶高度，栈顶 height [ 2 ] 出栈。计算 height [ 3 ] 和新的栈顶之间的水。计算完之后继续判断 current 和新的栈顶的关系。</p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/d290b4d7112bc6755fd0fbe17833d67d8d4cd8ca23b4d48bc912bd961d047d98-image.png" alt="image.png"></p></li><li><p><code>current</code> 指向的高度大于栈顶高度，栈顶 <code>height [ 1 ]</code> 出栈，栈空。所以把 <code>height [ 3 ]</code> 入栈。<code>currtent</code> 后移。</p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/32f62626e0a86ed91ee48bd94a923556cffaa6b492f4916051e084f610cfd0d3-image.png" alt="image.png"></p></li><li><p>然后 <code>current</code> 指向的高度小于栈顶 <code>height [ 3 ]</code> 的高度，height <code>[ 4 ]</code> 入栈。<code>current</code> 后移。</p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/3e26c51a348d968e48f60cbc6efadac1ed108eec7f44bf5c174ace3c1e3289aa-image.png" alt="image.png"></p></li><li><p>然后 <code>current</code> 指向的高度小于栈顶 <code>height [ 4 ]</code> 的高度，<code>height [ 5 ]</code> 入栈。<code>current</code> 后移。</p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/885b5225d840ba21b2219f76e41e74324f95d8a27d59e50a1066606cb64b5e7e-image.png" alt="image.png"></p></li><li><p>然后 current 指向的高度大于栈顶 height [ 5 ] 的高度，将栈顶 height [ 5 ] 出栈，然后计算 current 指向的墙和新栈顶 height [ 4 ] 之间的水。计算完之后继续判断 current 的指向和新栈顶的关系。此时 height [ 6 ] 不大于栈顶 height [ 4 ] ，所以将 height [ 6 ] 入栈。current 后移。</p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/e051367f8001808826039760cad0c9a3864403baf5c845d87be18752f3147a1b-image.png" alt="image.png"></p></li><li><p>然后 current 指向的高度大于栈顶高度，将栈顶 height [ 6 ] 出栈。计算和新的栈顶 height [ 4 ] 组成两个边界中的水。然后判断 current 和新的栈顶 height [ 4 ] 的关系，依旧是大于，所以把 height [ 4 ] 出栈。计算 current 和 新的栈顶 height [ 3 ] 之间的水。然后判断 current 和新的栈顶 height [ 3 ] 的关系，依旧是大于，所以把 height [ 3 ] 出栈，栈空。将 current 指向的 height [ 7 ] 入栈。current 后移。</p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/1f82b54ad14a3014908ddcbc13aaf46d2f3260f78277c6ec801aae28d1b17f98-image.png" alt="image.png"></p></li></ul><p><strong>我们根据栈模板中提到的<code>必写代码</code>来分析如下答案</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 1. 必写代码之一：对原始数据的循环遍历</span></span><br><span class="line">    <span class="keyword">while</span> (current &lt; height.length) &#123;</span><br><span class="line">      <span class="comment">// 2. 必写代码之二：对栈的判空，不管是用while还是if</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; height[current] &gt; height[stack.peek()]) &#123;</span><br><span class="line">          <span class="comment">// 3. 必写代码之三：取出栈顶元素</span></span><br><span class="line">            <span class="keyword">int</span> h = height[stack.peek()];</span><br><span class="line">            <span class="comment">// 4. 必写代码之四：出栈</span></span><br><span class="line">            stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (stack.empty()) &#123; <span class="comment">// 栈空就出去</span></span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 获取栈顶元素之后的具体比较逻辑</span></span><br><span class="line">            <span class="keyword">int</span> distance = current - stack.peek() - <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">int</span> min = Math.min(height[stack.peek()], height[current]);</span><br><span class="line">            sum = sum + distance * (min - h);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 5. 必写代码之五：入栈</span></span><br><span class="line">      <span class="comment">// 对元素数据里的每一个元素都进行栈操作</span></span><br><span class="line">        stack.push(current); </span><br><span class="line">        current++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode20. 有效的括号</title>
      <link href="post/3163c5fe.html"/>
      <url>post/3163c5fe.html</url>
      
        <content type="html"><![CDATA[<p><strong>栈模板<a href="./%E4%BD%BF%E7%94%A8%E6%A0%88%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3.md">使用栈解题思想</a></strong></p><a id="more"></a><p>先从使用栈的几个前提条件出发：</p><ol><li><p>是否涉及到<strong>比较</strong>：括号匹配，肯定涉及到左右括号的比较</p></li><li><p>是否涉及到<strong>延迟比较</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种情况就是不涉及到延迟比较</span></span><br><span class="line">输入: <span class="string">&quot;()[]&#123;&#125;&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line"><span class="comment">// 这种情况就是涉及到了延迟比较，最左侧的大括号要和最右侧的大括号比较，之间隔了一堆中括号</span></span><br><span class="line">输入: <span class="string">&quot;&#123;[]&#125;&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>满足了延迟比较的特点，所以使用栈来辅助解题</strong></p><p><strong>我们根据栈模板中提到的<code>必写代码</code>来分析如下答案</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">      <span class="comment">// 1. 必写代码之一：对原始数据的循环遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">          <span class="comment">// 对元素数据里的每一个元素都进行栈操作</span></span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">              <span class="comment">// 2. 必写代码之五：入栈</span></span><br><span class="line">                stk.push(s[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 3. 必写代码之二：对栈的判空，不管是用while还是if</span></span><br><span class="line">                <span class="keyword">if</span>(stk.empty())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 4. 必写代码之三：取出栈顶元素</span></span><br><span class="line">                <span class="keyword">char</span> topChar = stk.top();</span><br><span class="line">              <span class="comment">// 5. 必写代码之四：出栈</span></span><br><span class="line">                stk.pop();</span><br><span class="line">              <span class="comment">// 获取栈顶元素之后的具体比较逻辑</span></span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; topChar != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; topChar != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topChar != <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用栈解题思想</title>
      <link href="post/ba10a29b.html"/>
      <url>post/ba10a29b.html</url>
      
        <content type="html"><![CDATA[<p><strong>栈作为一种数据结构能很好的和其他算法思想，如动态规划，滑动窗口等结合。</strong></p><a id="more"></a><p><strong>更新1：解题时要区分是使用单调栈还是栈，两者的区别就是如果题目在某一次数组元素的循环中，也就是某一次外层循环中涉及到对多个栈内元素进行操作，则就是单调栈的题目，否则就是栈的题目；如果使用单调栈则必写代码之二处为where，若为栈则必写代码之二处为if</strong></p><p><strong>判断一道题是否能用栈来实现需要基本满足以下几个条件，并且在解题的时候需要逐步分析</strong></p><ol><li>是否涉及到元素之间的<strong>比较</strong>：该点是第二点的前提</li><li>是否涉及到<strong>延迟比较</strong>：延迟比较的意思是当我处理到某个元素，并且涉及到该元素与其他元素之间比较的时候，我不立刻进行而是把这个元素<code>保存</code>起来，等到时机成熟的时候才把他拿出来进行操作，保存用栈来说就<code>入栈(stack.push())</code>，把数据存进<code>&quot;冰箱&quot;</code>里，当需要拿出来比较的时候就使用<code>获取栈顶元素(stack.top())</code>。保存这种功能也是数组，队列，栈等数据结构所能提供的。<strong>注：如果分析到第二部涉及到延迟比较的话，大概率就使用栈或者队列等数据结构来辅助解题了，都不用再分析第三步了</strong></li><li>元素之间的比较是否只有<strong>一次</strong>：若元素之间的比较只有一次，那么我们在处理完某轮元素之间的比较之后就<code>放弃</code>该元素，因为永远不会再被用到，这里的<code>放弃</code>通俗化来说就是删除，而栈就是有<code>出栈(stack.pop())</code>这种操作</li><li>是否涉及到了<strong>逆序</strong>操作，根据栈先入后出的性质能够很好地执行逆序操作</li></ol><p><strong>使用栈时候需要注意的几点</strong></p><ol><li><p>不管题目是怎么样子的，如果用到了<code>栈</code>思想，在代码里<strong>一定！一定！一定</strong>会有</p><ol><li><p> 必写代码之一：对于原始数据的遍历，对元素数据里的每一个元素都进行栈操作</p></li><li><p>必写代码之二：<code>while(!stack.empty()) 或 if(!stack.empty())</code>，即判断栈非空</p></li><li><p>必写代码之三：<code>stack.top()</code>，即取出栈顶元素(<strong>根据top()的语法是不出栈的</strong>)进行比较操作，<strong>这里的比较操作涉及到获取栈顶元素之后的具体比较逻辑，具体问题具体分析</strong></p></li><li><p>必写代码之四：<code>stack.pop()</code>，即出栈顶元素(<strong>根据pop()的语法是单纯出栈不返回栈顶元素的</strong>)，因为元素只比较一次，比较完之后就出栈</p></li><li><p>必写代码之五：<code>stack.push(xxx)</code>，即入栈，因为需要延迟比较，所以把元素先入栈保存起来等待日后使用</p></li></ol></li></ol><p><strong>反正做栈的题目想都不用想直接现在代码里写上以上的几份代码，只不过代码存在的地方还得具体问题具体分析。</strong></p><p><strong>以下为用栈做辅助数据结构的简易模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    返回值 function(<span class="built_in">vector</span>&lt;T&gt;&amp; sources) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = sources.size();</span><br><span class="line">        <span class="built_in">stack</span>&lt;T&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sources.size(); ++i) &#123;</span><br><span class="line">            <span class="comment">// soures[i] &gt; soures[st.top()]为栈顶元素和当前数组处理元素之间的比较，这里仅是一个例子</span></span><br><span class="line">            <span class="comment">// 这里有一种简易判断循环条件的方法，就是判断当前扫描到的数组元素要怎样才能不经处理就可以直接执行第五步入栈</span></span><br><span class="line">            <span class="comment">// 那么循环条件就是该方法的反面</span></span><br><span class="line">            <span class="comment">// 例如果当前处理数组元素值 小于 栈顶元素的话就能直接入栈的话</span></span><br><span class="line">            <span class="comment">// 则while其中一个循环条件就为sources[i] &gt;= sources[st.top()]</span></span><br><span class="line">            <span class="keyword">while</span> (!st.empty() &amp;&amp; sources[i] &gt;= sources[st.top()]) &#123;</span><br><span class="line">                <span class="comment">// 3. 必写代码之三：取出栈顶元素</span></span><br><span class="line">                T t = st.top(); </span><br><span class="line">                <span class="comment">// 4. 必写代码之四：出栈</span></span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="comment">// 使用栈顶元素做一些具体操作</span></span><br><span class="line">              ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 5. 必写代码之五：入栈</span></span><br><span class="line">            <span class="comment">// 根据大量题目的验证，栈的push操作绝大部分是固定在while循环外的</span></span><br><span class="line">            <span class="comment">// 也就是说不管有没有进行栈顶元素和当前数组元素的比较判断，栈的push操作可以无脑写在while循环体外的第一行</span></span><br><span class="line">          <span class="comment">// 由于while的其中一个条件为!st.empty()，也就是说当栈为空的时候，这行代码还能保证无条件入栈一个初始元素</span></span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> 返回值;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode452. 用最少数量的箭引爆气球</title>
      <link href="post/751bc64e.html"/>
      <url>post/751bc64e.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://mp.weixin.qq.com/s/NH8GFMcRm5UK0HmVhdNjMQ">公众号（labuladong），略有增删</a></strong></p><a id="more"></a><p>其实稍微思考一下，这个问题和<a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">Leetcode435. 区间调度算法</a>一模一样！如果最多有<code>n</code>个不重叠的区间，那么就至少需要<code>n</code>个箭头穿透所有区间：</p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/1598197780069.png" alt="1598197780069"></p><p>只是有一点不一样，在<code>intervalSchedule</code>算法中，如果两个区间的边界触碰，不算重叠；而按照这道题目的描述，箭头如果碰到气球的边界气球也会爆炸，所以说相当于区间的边界触碰也算重叠：</p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/1598197806078.png" alt="1598197806078"></p><p>所以只要将之前的算法稍作修改，就是这道题目的答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 按 end 升序排序</span></span><br><span class="line">        Arrays.sort(points, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 至少有一个区间不相交</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 排序后，第一个区间就是 x</span></span><br><span class="line">        <span class="keyword">int</span> x_end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] point : points) &#123;</span><br><span class="line">            <span class="keyword">int</span> start = point[<span class="number">0</span>];</span><br><span class="line">          <span class="comment">// 把 &gt;= 改成 &gt; 就行了</span></span><br><span class="line">            <span class="keyword">if</span> (start &gt; x_end) &#123;</span><br><span class="line">                <span class="comment">// 找到下一个选择的区间了</span></span><br><span class="line">                count++;</span><br><span class="line">                x_end = point[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode435. 无重叠区间</title>
      <link href="post/99462b61.html"/>
      <url>post/99462b61.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://mp.weixin.qq.com/s/NH8GFMcRm5UK0HmVhdNjMQ">公众号（labuladong），略有增删</a></strong></p><a id="more"></a><p>举个例子，<code>intvs=[[1,3],[2,4],[3,6]]</code>，这些区间最多有两个区间互不相交，即<code>[[1,3],[3,6]]</code>，你的算法应该返回 2。注意边界相同并不算相交。</p><p>这个问题在生活中的应用广泛，比如你今天有好几个活动，每个活动都可以用区间<code>[start,end]</code>表示开始和结束的时间，请问你<strong>今天最多能参加几个活动呢？</strong></p><h3 id="1-贪心"><a href="#1-贪心" class="headerlink" title="1. 贪心"></a>1. 贪心</h3><p>这个问题有许多看起来不错的解决思路，实际上都不能得到正确答案。比如说：</p><p>也许我们可以每次选择可选区间中开始最早的那个？但是可能存在某些区间开始很早，但是很长，使得我们错误地错过了一些短的区间。</p><p>或者我们每次选择可选区间中最短的那个？或者选择出现冲突最少的那个区间？这些方案都能很容易举出反例，不是正确的方案。</p><p>正确的思路其实很简单，可以分为以下三步：</p><ol><li>从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中<strong>结束最早的</strong>（end 最小）。</li><li>把所有与 x 区间相交的区间从区间集合 intvs 中删除。</li><li>重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。</li></ol><p>把这个思路实现成算法的话，可以按每个区间的<code>end</code>数值升序排序，因为这样处理之后实现步骤 1 和步骤 2 都方便很多:</p><p>现在来实现算法，对于步骤 1，由于我们预先按照<code>end</code>排了序，所以选择 x 是很容易的。关键在于，如何去除与 x 相交的区间，选择下一轮循环的 x 呢？</p><p><strong>由于我们事先排了序</strong>，不难发现所有与 x 相交的区间必然会与 x 的<code>end</code>相交；如果一个区间不想与 x 的<code>end</code>相交，它的<code>start</code>必须要大于（或等于）x 的<code>end</code>：</p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/1598197561836.png" alt="1598197561836"></p><p>我们已经会求最多有几个区间不会重叠了，那么剩下的不就是至少需要去除的区间吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 按 end 升序排序</span></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 至少有一个区间不相交</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 排序后，第一个区间就是 x</span></span><br><span class="line">        <span class="keyword">int</span> x_end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">int</span> start = interval[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (start &gt;= x_end) &#123;</span><br><span class="line">                <span class="comment">// 找到下一个选择的区间了</span></span><br><span class="line">                count++;</span><br><span class="line">                x_end = interval[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.length - count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode45. 跳跃游戏 II</title>
      <link href="post/b3605e8a.html"/>
      <url>post/b3605e8a.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/jump-game-ii/">Leetcode题解（yang tianrui），略有增删</a></strong></p><a id="more"></a><p><strong>能用贪心做的题目一定能用动态规划做</strong></p><h3 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1. 动态规划"></a>1. 动态规划</h3><ol><li><p>状态：数组下标(变化量)，用<code>i</code>来表示。<code>dp[i]</code>表示从起点开始，为跳到点<code>i</code>需要的最小步数。</p></li><li><p>最小状态：<code>dp[0] = 0</code>，原点不用跳</p></li><li><p>状态转移方程(通过对状态的循环多次，有几个状态就有几层循环，对立相反的状态只需写两行代码即可，不需要循环)：<strong>一个状态一次循环，第二层循环可不是状态量的循环，之前在动态规划模板中也有说明</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123; </span><br><span class="line">    <span class="keyword">if</span> (j + nums[j] &gt;= i) &#123; </span><br><span class="line">      dp[i] = min(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回最终状态：return dp[n]；或者其他</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很遗憾动态规划超时了，所以想办法优化。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(n, <span class="number">0x3f3f3f3f</span>)</span></span>;</span><br><span class="line">      dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123; </span><br><span class="line">              <span class="keyword">if</span> (j + nums[j] &gt;= i) &#123; <span class="comment">// 只要前面的点能跳到i点就更新最小值</span></span><br><span class="line">                dp[i]] = min(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-贪心"><a href="#2-贪心" class="headerlink" title="2. 贪心"></a>2. 贪心</h3><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II/1598194823358.png" alt="1598194823358"></p><hr><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II/1598194857918.png" alt="1598194857918"></p><hr><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II/1598195045238.png" alt="1598195045238"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> current_max_index = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> pre_max_max_index = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> jump_min = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; current_max_index)&#123;  <span class="comment">// 若无法继续向前移动了，才进行跳跃</span></span><br><span class="line">                jump_min++;     <span class="comment">// 更新当前可当最远位置</span></span><br><span class="line">                current_max_index = pre_max_max_index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pre_max_max_index &lt; nums[i] + i)&#123;</span><br><span class="line">                pre_max_max_index = nums[i] + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jump_min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode55. 跳跃游戏</title>
      <link href="post/3199df03.html"/>
      <url>post/3199df03.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/n-queens/solution/hui-su-suan-fa-xiang-jie-by-labuladong/">Leetcode题解（yang tianrui），略有增删</a></strong></p><a id="more"></a><p><strong>能用贪心做的题目一定能用动态规划做</strong></p><h3 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1. 动态规划"></a>1. 动态规划</h3><ol><li><p>状态：数组下标(变化量)，用<code>i</code>来表示。<code>dp[i]</code>表示从起点开始，能否跳到以<code>i</code>结尾的地方(<strong>bool值</strong>)</p></li><li><p>最小状态：<code>dp[0] = true</code>起点自身当然能跳到</p></li><li><p>状态转移方程(通过对状态的循环多次，有几个状态就有几层循环，对立相反的状态只需写两行代码即可，不需要循环)：<strong>一个状态一次循环，第二层循环可不是状态量的循环，之前在动态规划模板中也有说明</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">    <span class="comment">// 如果之前的j节点可达，并且从此节点可以到跳到i</span></span><br><span class="line">    <span class="keyword">if</span> (dp[j] &amp;&amp; nums[j] + j &gt;= i) &#123;</span><br><span class="line">      dp[i] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回最终状态：<code>dp[nums.length - 1];</code></p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为什么Leetcode上超时了，嘤嘤嘤</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(len, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &amp;&amp; nums[j] + j &gt;= i)&#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-贪心"><a href="#2-贪心" class="headerlink" title="2. 贪心"></a>2. 贪心</h3><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/1598192236739.png" alt="1598192236739"></p><hr><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/1598192249692.png" alt="1598192249692"></p><hr><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/1598192275963.png" alt="1598192275963"></p><hr><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/1598192350058.png" alt="1598192350058"></p><hr><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/1598192551035.png" alt="1598192551035"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            index.push_back(i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> jump = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_index = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(jump &lt; index.size() &amp;&amp; jump &lt;= max_index)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max_index &lt; index[jump])&#123;</span><br><span class="line">                max_index = index[jump];</span><br><span class="line">            &#125;</span><br><span class="line">            jump++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jump == index.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode402. 移掉K位数字</title>
      <link href="post/8459516d.html"/>
      <url>post/8459516d.html</url>
      
        <content type="html"><![CDATA[<p><strong>假设数字1432219， k = 1，我们只去掉一个数字，应该去掉哪个？如果k&gt;1，我们应该按照什么顺序与策略进行删除数字，得到结果最优？</strong></p><a id="more"></a><h3 id="1-贪心算法"><a href="#1-贪心算法" class="headerlink" title="1. 贪心算法"></a>1. 贪心算法</h3><p>尽可能让的得到的新数字优先最高位最小，这就是贪心思想</p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode402-%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/1598183497591.png" alt="1598183497591"></p><hr><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode402-%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/1598183694639.png" alt="1598183694639"></p><p><strong>若涉及到<code>比较，保留和删除</code>数组前后元素的情况，则大概率和<code>栈</code>或者<code>队列</code>结合起来</strong></p><p><strong>这两个数据结构能把数据存入(push)并且保留在体内进行判断(栈头或者队头元素与当前元素的比较)，同时又能通过出栈，出队(pop)，出队来进行删除</strong></p><p><strong>针对本道题</strong></p><ol><li>有元素之间的比较吗？有呀！看上一幅图，栈头元素与当前元素之间的比较</li><li>有元素的保留吗？有呀！把最优结果保存在栈中</li><li>有元素的删除吗？有呀！根据比较的结果删除元素(把栈头的元素出栈)</li></ol><p><strong>这还不用栈来实现？</strong></p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode402-%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/1598184048212.png" alt="1598183694639"></p><hr><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode402-%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/1598184615408.png" alt="1598183694639"></p><hr><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode402-%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/1598184651484.png" alt="1598183694639"></p><hr><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode402-%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/1598184759377.png" alt="1598183694639"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> number = num[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">          <span class="comment">// 这里使用while而不用if的原因是</span></span><br><span class="line">            <span class="comment">// 如果特例为num = &quot;1234560&quot;，而k=6，则正确答案为0，可是使用if的结果为1</span></span><br><span class="line">            <span class="keyword">while</span>(s.size() != <span class="number">0</span> &amp;&amp; s[s.size() - <span class="number">1</span>] &gt; number &amp;&amp; k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                s.pop_back();</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(number != <span class="number">0</span> || s.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                s.push_back(number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(s.size() != <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            s.pop_back();</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">            result.append(<span class="number">1</span>, <span class="string">&#x27;0&#x27;</span> + s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == <span class="string">&quot;&quot;</span>? <span class="string">&quot;0&quot;</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode376. 摆动序列</title>
      <link href="post/603e84c0.html"/>
      <url>post/603e84c0.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/wiggle-subsequence/solution/bai-dong-xu-lie-dong-tai-gui-hua-tan-xin-jie-fa-by/">Leetcode题解（星缘），略有增删</a></strong></p><p><strong>能用贪心做的题目一定能用动态规划做</strong></p><a id="more"></a><h3 id="1-动态规划做法"><a href="#1-动态规划做法" class="headerlink" title="1. 动态规划做法"></a>1. 动态规划做法</h3><ol><li><p>状态：长度维度标示(变化量)，用<code>i</code>来表述；<strong>当前数组位置的值相对于前一个相邻位置上的值是上升的还是下降的</strong>(相反对立量)，用<code>j</code>来表示，<code>j</code>的值为0和1；<code>dp[i][j] </code>标示为 以nums[i] 位置为结尾的 上升/下降 状态所对应的摇摆序列的最大长度</p></li><li><p>最小状态：<code>dp[0][1] = 1; dp[0][0] = 1;</code></p></li><li><p>状态转移方程(通过对状态的循环多次，有几个状态就有几层循环，对立相反的状态只需写两行代码即可，不需要循环)</p><p><strong>一个变化状态量和一个对立相反状态量，所以进行一次循环外加一次if判断</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们分析一下 假设函数 dp(i) 标示 0-i 的摆序列最长的数字，我们如何求得 dp(i+1) ?</span></span><br><span class="line"><span class="comment">//1. 如果 nums[i+1] &gt; nums[i]   （末尾向上升）则 dp(i)如果是下降属性   dp(i+1) = dp(i) + 1</span></span><br><span class="line"><span class="comment">// 如果 dp(i) 也是一个上升属性呢？ 则 dp(i+1) = dp(i)</span></span><br><span class="line"><span class="comment">//2. 如果 nums[i+1] &lt; nums[i]   (末尾向下) 则 dp(i) 如果是上升属性    dp(i+1) = dp(i) + 1</span></span><br><span class="line"><span class="comment">// 如果 dp(i) 也是一个下降属性呢？ 则 dp(i+1) = dp(i)</span></span><br><span class="line"><span class="comment">//3. 如果 nums[i+1] == nums[i]  (需要跳过的) 则 dp(i+1) = dp(i)</span></span><br></pre></td></tr></table></figure></li><li><p>返回最终状态：<code>return max(dp[n-1][0], dp[n-1][1]);</code></p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = nums.size();</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(n,<span class="built_in">vector</span>(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i]&lt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">      dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&gt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">      dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">      dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]; </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">      dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max(dp[n<span class="number">-1</span>][<span class="number">0</span>],dp[n<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-贪心算法-伪，好像这种做法看不出贪心在哪里-，但毕竟是题解里给出的，先放着，但是肯定涉及到dp数组的维度压缩"><a href="#2-贪心算法-伪，好像这种做法看不出贪心在哪里-，但毕竟是题解里给出的，先放着，但是肯定涉及到dp数组的维度压缩" class="headerlink" title="2. 贪心算法(伪，好像这种做法看不出贪心在哪里-_-||，但毕竟是题解里给出的，先放着，但是肯定涉及到dp数组的维度压缩)"></a>2. 贪心算法(伪，好像这种做法看不出贪心在哪里-_-||，但毕竟是题解里给出的，先放着，但是肯定涉及到dp数组的维度压缩)</h3><p><strong>其实基于动态规划 只需要考虑一点 “是否可以通过局部最优得到 全局最优？”</strong></p><p>有动态规划我们可以看出当然可以？我们可以从每次最优的里面选取下一个最优，最后对比即可</p><p>等量翻译一下 用up 代表 <code>dp[i][1]</code> ，用down 代表<code>dp[i][0]</code> 。剩下<code>dp[i-1][0/1] </code>如何标示，仔细考虑一下我们 在动态规划中只是想要让当前值继承前一个。如果我们不操作 up 或 down 是否就等同了 就是代码中注释部分</p><p><strong>感觉有点像二维dp数组的降维操作，只不过又把一维的dp数组使用单独的变量名来表示。即用up 代表 <code>dp[i][1]</code> ，用down 代表<code>dp[i][0]</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = nums.size();</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="keyword">int</span> up=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> down=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i]&lt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">      down = up + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//up = up</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&gt; nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">      up = down +<span class="number">1</span>;</span><br><span class="line">      <span class="comment">//down = down</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*else&#123;</span></span><br><span class="line"><span class="comment">    up = up;</span></span><br><span class="line"><span class="comment">      down = down;</span></span><br><span class="line"><span class="comment">     &#125;*/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max(down,up);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-贪心算法-真"><a href="#3-贪心算法-真" class="headerlink" title="3. 贪心算法(真)"></a>3. 贪心算法(真)</h3><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/1598181295580.png" alt="1598181295580"></p><p><strong>简而言之，如何才能尽可能构造成一个摇摆情况呢？如果最高的和你都够不成摇摆情况，那就无论如何也不能摇摆了，这就涉及到了贪心算法，尽可能用一串序列的最高或者最低位构造摇摆；先不管具体代码实现，因为代码实现五花八门。一道题要么能用贪心，要么不能用，为什么能用贪心已经说明白了，</strong></p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/1598181409068.png" alt="1598181409068"></p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/1598182100790.png" alt="1598182100790"></p><p><strong>根据贪心思想，简而言之就是我要尽可能用极大极小值来作为子序列的构成部分。其实就是图中红色部分长度=7，如果一段序列一直增加或者减少则不增加最长序列长度，一旦改变了变化方向就另摇摆最大长度+1</strong></p><p><strong>状态条件判断可以参考动态规划解法里的思想，因为能用贪心做的一定能用动态规划做</strong></p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/1598181697121.png" alt="1598181697121"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode455. 分发饼干</title>
      <link href="post/fbfa3558.html"/>
      <url>post/fbfa3558.html</url>
      
        <content type="html"><![CDATA[<p><strong>能用贪心算法的题目一定能用动态规划来做，但是这道题可能是由于状态转移方程或者状态没有设定正确，导致最后的结果与题意有一定差距，但是也能证明使用动态规划的想法是正确的的</strong></p><a id="more"></a><h4 id="动态规划做法-错误"><a href="#动态规划做法-错误" class="headerlink" title="动态规划做法(错误)"></a>动态规划做法(错误)</h4><ol><li><p>状态：孩子和饼干数组的下标<code>i和j</code>，<code>dp[i][j]</code>表示用前<code>j</code>块饼干能满足前<code>i</code>个孩子之间最大多少个孩子</p></li><li><p>最小状态：<code>dp[...][0] = 0</code>，没有饼干提供自然一个孩子都不能满足，<code>dp[0][...] = 0</code>，没有孩子，即使有饼干也无法满足，基于以上初始值，直接使用<code>vector&lt;vector&lt;int&gt;&gt; dp(len1 + 1, vector&lt;int&gt;(len2 + 1, 0));</code>来初始化</p></li><li><p>状态转移方程(通过对状态的循环多次，有几个状态就有几层循环，对立相反的状态只需写两行代码即可，不需要循环)：<strong>两个状态，两次嵌套循环</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种状态转移方程会导致一块饼干被多个孩子分食，这也是与题意相悖的地方</span></span><br><span class="line"><span class="comment">// 如果题目给定同一重量的饼干有无数块，这种动态规划做法是完全正确的！！！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++)&#123;</span><br><span class="line">    <span class="comment">// 同样由于状态设定导致饼干数组下标和状态量差了一个偏移位</span></span><br><span class="line">    <span class="comment">// 如果当前作比较的饼干重量  大于  当前作比较的孩子满意饼干大小</span></span><br><span class="line">    <span class="keyword">if</span>(s[j - <span class="number">1</span>] &gt;= g[i - <span class="number">1</span>])&#123;</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 有人会说既然一个饼干只能用一次，那么转移方程写成dp[i][j] = dp[i - 1][j - 1] + 1不就好了</span></span><br><span class="line">      <span class="comment">// 确实会有这种想法，但是如果数据集为</span></span><br><span class="line">      <span class="comment">// [10,9,8,7]</span></span><br><span class="line"><span class="comment">// [5,6,7,8]</span></span><br><span class="line">      <span class="comment">// 正确结果为2，但是按照上面的转移方程结果就是1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回最终状态：<code>dp[len1][len2]</code>;</p></li></ol><h4 id="贪心做法"><a href="#贪心做法" class="headerlink" title="贪心做法"></a>贪心做法</h4><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/1598157227573.png" alt="1598157227573"></p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/1598157250372.png" alt="1598157250372"></p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/1598158415263.png" alt="1598158415263"></p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/1598175764239.png" alt="1598175764239"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        sort(s.begin(), s.end());</span><br><span class="line">        sort(g.begin(), g.end());</span><br><span class="line">        <span class="keyword">int</span> cookie = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cookie &lt; s.size() &amp;&amp; child &lt; g.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[child] &lt;= s[cookie])&#123; <span class="comment">// 当孩子的满足因子小于等于糖果大小时</span></span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            cookie++;<span class="comment">// 无论成功失败，每个糖果只尝试一次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> child;<span class="comment">// 最终child即为得到满足的孩子的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="post/a4ce31d2.html"/>
      <url>post/a4ce31d2.html</url>
      
        <content type="html"><![CDATA[<p><strong>预备知识：贪心法，钞票支付问题，Leetcode对应题目为<a href="https://leetcode-cn.com/problems/coin-change/">Leetcode322-零钱兑换</a></strong></p><a id="more"></a><p>题目描述：有1元，5元，10元，20元，100元，200元的钞票<strong>无数张</strong>。现使用这些钞票支付X元，最少需要几张？</p><p>例如，X = 628</p><p><code>最佳支付方法</code>：3张200元的，1张20元的，1张5元的，3张1元的</p><p>共需要3+1+1+1+3=8张</p><p>直觉告诉我们：<code>尽可能多</code>的使用<code>面值较大</code>的钞票能使所需钞票数最小。</p><p><strong>贪心法：遵循某种规律，不断贪心的选取<code>当前最优</code>策略的算法设计方法</strong></p><h4 id="为什么这么做一定是对的？"><a href="#为什么这么做一定是对的？" class="headerlink" title="* 为什么这么做一定是对的？"></a>* 为什么这么做一定是对的？</h4><p>面额为1元，5元，10元，20元，100元，200元的任意钞票是比自己小的面额的<strong>倍数关系</strong>，所以当时用一张面额较大的钞票时，若使用较小面额钞票替换，一定<code>能并且需要更多的其他面额的钞票</code><strong>，比如我需要1张200元面额钞票，等同于2张100元，10张20元；需要1张10元的，等同于1张5元的加上5张1元的，故当前最优解即为全局最优解</strong>。</p><p>思考：如果增加7元面额，贪心还成立吗？</p><p><strong>不成立！</strong>假设我们要支付一个14元的商品，如果采用之前的<code>尽可能多</code>的使用<code>面值较大</code>的钞票能使所需钞票数最小策略：</p><p>14 = 1张10元+4张1元，一共需要5张；但是最小的支付方式是2张7元的就够了。因为增加一个7元面额的钞票之后就违背了”任意钞票是比自己小的面额的<strong>倍数关系</strong>“原则</p><h4 id="虽然添加了7元面额钞票不能用贪心算法，但是可以用动态规划方法"><a href="#虽然添加了7元面额钞票不能用贪心算法，但是可以用动态规划方法" class="headerlink" title="* 虽然添加了7元面额钞票不能用贪心算法，但是可以用动态规划方法"></a>* 虽然添加了7元面额钞票不能用贪心算法，但是可以用动态规划方法</h4><h4 id="贪心只是动态规划的一种特例，其实基于贪心-只需要考虑一点“局部最优是否可以-推出-全局最优”"><a href="#贪心只是动态规划的一种特例，其实基于贪心-只需要考虑一点“局部最优是否可以-推出-全局最优”" class="headerlink" title="* 贪心只是动态规划的一种特例，其实基于贪心 只需要考虑一点“局部最优是否可以 推出 全局最优”"></a>* 贪心只是动态规划的一种特例，其实基于贪心 只需要考虑一点<u>“局部最优是否可以 推出 全局最优”</u></h4><p>这里给出一个结论</p><h4 id="能用贪心的必能用动态规划，但是能用动态规划的不一定能用贪心"><a href="#能用贪心的必能用动态规划，但是能用动态规划的不一定能用贪心" class="headerlink" title="能用贪心的必能用动态规划，但是能用动态规划的不一定能用贪心"></a><u>能用贪心的必能用动态规划，但是能用动态规划的不一定能用贪心</u></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> RMB[] = &#123;<span class="number">200</span>, <span class="number">100</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;<span class="comment">// 钞票面额，从大到小排列</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> NUM = <span class="number">6</span>; <span class="comment">// 6种面额钞票</span></span><br><span class="line">  <span class="keyword">int</span> X = <span class="number">628</span>;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; i++)&#123;</span><br><span class="line">    <span class="comment">// 需要面额为RMB[i]的use张</span></span><br><span class="line">    <span class="comment">// 因为钞票面额从大到小排列，所以每次处理的都是当前最大面额钞票，以此获得局部最优解</span></span><br><span class="line">    <span class="keyword">int</span> use = X / RMB[i];</span><br><span class="line">   count += use;<span class="comment">// 总计增加use张</span></span><br><span class="line">    X = X - RMB[i] * use;<span class="comment">// 将总面额减去使用RMB[i]已组成的金额</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;总共需要%d张&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-分糖果"><a href="#1-分糖果" class="headerlink" title="1. 分糖果"></a>1. 分糖果</h3><p>已知一些孩子和一些糖果，每个孩子都有需求因子g，每个糖果有大小s，当某个糖果的大小s&gt;=某个孩子的需求因子g时，代表该糖果可以满足该孩子；求使用这些糖果，最多能满足多少孩子？(注意：每个孩子最多只能用1个糖果满足)<strong>题源来自<a href="https://leetcode-cn.com/problems/assign-cookies/">Leetcode455. 分发饼干</a>)</strong></p><h3 id="2-摆动序列"><a href="#2-摆动序列" class="headerlink" title="2. 摆动序列"></a>2. <a href="https://leetcode-cn.com/problems/wiggle-subsequence/">摆动序列</a></h3><p><strong>题源来自<a href="https://leetcode-cn.com/problems/wiggle-subsequence/">Leetcode376. 摆动序列</a></strong></p><h3 id="3-移掉K位数字"><a href="#3-移掉K位数字" class="headerlink" title="3. 移掉K位数字"></a>3. 移掉K位数字</h3><p><strong>题源来自<a href="https://leetcode-cn.com/problems/remove-k-digits/">Leetcode402. 移掉K位数字</a></strong></p><h3 id="4-跳跃游戏"><a href="#4-跳跃游戏" class="headerlink" title="4. 跳跃游戏"></a>4. 跳跃游戏</h3><p><strong>题源来自<a href="https://leetcode-cn.com/problems/jump-game/">Leetcode55. 跳跃游戏</a></strong></p><h3 id="5-区间调度问题"><a href="#5-区间调度问题" class="headerlink" title="5. 区间调度问题"></a>5. 区间调度问题</h3><p><strong>题源来自</strong><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">Leetcode435. 无重叠区间</a></p><p><strong>题源来自</strong><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">Leetcode452. 用最少数量的箭引爆气球</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode322. 零钱兑换</title>
      <link href="post/69caf82b.html"/>
      <url>post/69caf82b.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/">Leetcode题解（labuladong），略有增删</a></strong></p><a id="more"></a><p><strong>虽然烦，但还是要写公式-_-||</strong></p><ol><li><p>状态：数组下标(变化量)，使用<code>i</code>来表示；零钱总数(变化量0)，使用<code>j</code>来表示，则<code>dp[i][j]</code>表示最少使用多少枚前<code>i</code>个枚硬币才能刚好凑出总共<code>j</code>的零钱，如果不能刚好凑出则返回-1</p></li><li><p>最小状态：<code>dp[0][...] = -1</code>表示用前0枚硬币能刚好凑出目的零钱，显然不可能，<code>dp[...][0] = 0</code>表示用前…枚硬币凑出0块钱，显然有一枚硬币都不需要</p></li><li><p>状态转移方程(通过对状态的循环多次，有几个状态就有几层循环，对立相反的状态只需写两行代码即可，不需要循环)：<strong>两个状态，两次嵌套循环</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)&#123;</span><br><span class="line">    <span class="comment">// 主要这里的coins[i - 1]主要是因为coins[0]代表前1个硬币，两者存在一个偏差</span></span><br><span class="line">    <span class="keyword">if</span>(j &gt;= coins[i - <span class="number">1</span>])&#123;</span><br><span class="line">      dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - coins[i - <span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回最终状态：dp[amount] == amount + 1 ? -1 : dp[amount];</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// vector&lt;int&gt; dp(amount + 1, amount + 1);</span></span><br><span class="line">    <span class="comment">// dp[0] = 0;</span></span><br><span class="line">    <span class="keyword">int</span> len = coins.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(len + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(amount + <span class="number">1</span>, amount + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)&#123;</span><br><span class="line">            <span class="comment">// 主要这里的coins[i - 1]主要是因为coins[0]代表前1个硬币，两者存在一个偏差</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt;= coins[i - <span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - coins[i - <span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len][amount] == amount + <span class="number">1</span> ? <span class="number">-1</span> : dp[len][amount];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="贪心解法详见贪心算法"><a href="#贪心解法详见贪心算法" class="headerlink" title="贪心解法详见贪心算法"></a>贪心解法详见<a href="./%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.md">贪心算法</a></h4>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode877. 石子游戏</title>
      <link href="post/c3fb2284.html"/>
      <url>post/c3fb2284.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/stone-game/solution/jie-jue-bo-yi-wen-ti-de-dong-tai-gui-hua-tong-yong/">Leetcode题解（labuladong），略有增删</a></strong></p><a id="more"></a><ol><li><p>状态：数组下标(变化量)，用下标<code>i</code>表示；先手还是后手拿(对立相反量)，表示成0与1<strong>不过题解中以pair形式表示，也是可以的，本质上还是只使用两个值来表示相反的量；注：本来对于数组元素的状态就是一个下标志<code>i</code>，但是如果同时考虑到假如在数组的左右两端取石头的话，还是比较容易想到，再添加一个状态量<code>j</code>，用dp[i] [j]表示石头数组左右两端之间的元素</strong>，则<code>dp[i][j].fir</code>表示从<code>piles[i...j]</code>之间先手能拿到的最大重量，<code>dp[i][j].sec</code>表示从<code>piles[i...j]</code>之间后手能拿到的最大重量</p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/1598078410105.png" alt="1598078410105"></p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/1598078445839.png" alt="1598078445839"></p></li><li><p>最小状态：<code>dp[i][i].fir = piles[i]，dp[i][i].sec = 0</code>，当只有一堆石头的时候先拿得全部，后拿什么都没有</p></li><li><p>状态转移方程(通过对状态的循环多次，有几个状态就有几层循环，对立相反的状态只需写两行代码即可，不需要循环)：<strong>三个状态量，其中两个变化量导致两次嵌套循环；一个对立相反量采用if判断</strong></p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/1598078682144.png" alt="1598078682144"></p><p><strong>同时要注意根据已知推未知，观察转移量的数组下标，<code>dp[i + 1][j]以及dp[i][j - 1]</code>，可以判断是从右下角往上推的</strong></p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/1598078752256.png" alt="1598078752256"></p><p><img src= "/img/loading.gif" data-lazy-src="assets/1598078827017.png" alt="1598078827017"></p></li><li><p>返回最终状态：<code>return dp[0][n−1].fir &gt; dp[0][n−1].sec</code>；<strong>我们想求的答案是先手和后手谁跟大</strong></p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = piles.size();</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; dp[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; len; j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">make_pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            dp[i][i].first = piles[i];</span><br><span class="line">            dp[i][i].second = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> left = piles[i] + dp[i + <span class="number">1</span>][j].second;</span><br><span class="line">                <span class="keyword">int</span> right = piles[j] + dp[i][j - <span class="number">1</span>].second;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">                    dp[i][j].first = left;</span><br><span class="line">                    dp[i][j].second = dp[i + <span class="number">1</span>][j].first;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j].first = right;</span><br><span class="line">                    dp[i][j].second = dp[i][j - <span class="number">1</span>].first;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][len - <span class="number">1</span>].first &gt; dp[<span class="number">0</span>][len - <span class="number">1</span>].second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode1143. 最长公共子序列</title>
      <link href="post/93d25cf.html"/>
      <url>post/93d25cf.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/longest-common-subsequence/solution/dong-tai-gui-hua-zhi-zui-chang-gong-gong-zi-xu-lie/">Leetcode题解（labuladong），略有增删</a></strong></p><a id="more"></a><p><strong>虽然烦，但还是要写公式-_-||</strong></p><ol><li><p>状态：两个字符串的下标(变量)，分别为i和j，<code>dp[i][j]</code>的含义是：对于<code>s1[1..i]</code>和<code>s2[1..j]</code>，它们的 LCS 长度是<code>dp[i][j]</code>。比如dp[2] [4] 的含义就是：对于<code>&quot;ac&quot;</code>和<code>&quot;babc&quot;</code>，它们的 LCS 长度是 2。我们最终想得到的答案应该是<code>dp[3][6]</code>。</p></li><li><p>最小状态：我们专门让索引为 0 的行和列表示空串，<code>dp[0][..]</code>和<code>dp[..][0]</code>都应该初始化为 0。比如说，按照刚才 dp 数组的定义，<code>dp[0][3]=0</code>的含义是：对于字符串<code>&quot;&quot;</code>和<code>&quot;bab&quot;</code>，其 LCS 的长度为 0。因为有一个字符串是空串，它们的最长公共子序列的长度显然应该是 0。</p></li><li><p>状态转移方程(通过对状态的循环多次，有几个状态就有几层循环，对立相反的状态只需写两行代码即可，不需要循环)：<strong>两个状态，两次嵌套循环，并且要想dp[i] [j]怎么和dp[i - 1] [j - 1]，dp[i] [j + 1]之类的下标元素产生关系</strong></p><p>用两个指针<code>i</code>和<code>j</code>从后往前遍历<code>s1</code>和<code>s2</code>，如果<code>s1[i]==s2[j]</code>，那么这个字符<strong>一定在lcs中</strong>；否则的话，<code>s1[i]</code>和<code>s2[j]</code>这两个字符<strong>至少有一个不在lcs中</strong>，需要丢弃一个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>])&#123;</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      dp[i][j] = max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回最终状态：return dp[len1] [len2];</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = text1.size(), len2 = text2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(len1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len2 + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode72. 编辑距离</title>
      <link href="post/3e308d14.html"/>
      <url>post/3e308d14.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-mian-shi-ti-xiang-jie-by-labuladong/">Leetcode题解（labuladong），略有增删</a></strong></p><a id="more"></a><p><strong>虽然烦，但还是要写公式-_-||</strong></p><ol><li><p>状态：应该很容易得出，两个字符串的下标对应着两个状态分别为i和j；<code>dp[i][j]</code>表示对于<code>s1[1..i]</code>和<code>s2[1..j]</code>，最少需要进行多少次的操作才能使s1彻底变成s2串</p></li><li><p>最小状态：<strong>专门让索引为 0 的行和列表示空串，这也是在二维dp数组中常见的操作，特意把下标为0的元素特殊化，同时把末尾元素也延长一位</strong>，都应该初始化为<code>dp[0][j] = j</code>和<code>dp[i][0] = i</code>，毕竟从空串变成一个长度为n的字符串就是不断地添加n次字符即可</p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/1598065825730.png" alt="1598065825730"></p></li><li><p>状态转移方程(通过对状态的循环多次，有几个状态就有几层循环，对立相反的状态只需写两行代码即可，不需要循环)：<strong>两个状态，两次嵌套循环</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每对字符s1[i]和s2[j]，可以有四种操作：</span></span><br><span class="line"><span class="keyword">if</span> s1[i] == s2[j]:</span><br><span class="line">    啥都别做（skip）</span><br><span class="line">    i, j 同时向前移动</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    三选一：</span><br><span class="line">        插入（insert）</span><br><span class="line">        删除（<span class="keyword">delete</span>）</span><br><span class="line">        替换（replace）</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> s1[i] == s2[j]:</span><br><span class="line">    <span class="keyword">return</span> dp(i - <span class="number">1</span>, j - <span class="number">1</span>)  # 啥都不做</span><br><span class="line"># 解释：</span><br><span class="line"># 本来就相等，不需要任何操作</span><br><span class="line"># s1[<span class="number">0.</span>.i] 和 s2[<span class="number">0.</span>.j] 的最小编辑距离等于</span><br><span class="line"># s1[<span class="number">0.</span>.i<span class="number">-1</span>] 和 s2[<span class="number">0.</span>.j<span class="number">-1</span>] 的最小编辑距离</span><br><span class="line"># 也就是说 dp(i, j) 等于 dp(i<span class="number">-1</span>, j<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>如果<code>s1[i]！=s2[j]</code>，就要对三个操作递归了，稍微需要点思考：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp(i - <span class="number">1</span>, j - <span class="number">1</span>) + <span class="number">1</span> # 替换</span><br><span class="line"># 解释：</span><br><span class="line"># 我直接把 s1[i] 替换成 s2[j]，这样它俩就匹配了</span><br><span class="line"># 同时前移 i，j 继续对比</span><br><span class="line"># 操作数加一</span><br></pre></td></tr></table></figure><p><strong>其实从i - 1和j - 1这个元素下标以及结合二维dp数组就能够猜到另外两种情况的下标对应着什么</strong></p><p><strong>大概率是dp[i - 1] [j]和dp[i] [j - 1]，事实也确实是这两种情况</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">    <span class="comment">// word下标是从0开始的，而dp下标是从1开始的，所以需要i - 1</span></span><br><span class="line">    <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])&#123;</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      dp[i][j] = min3(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>,dp[i][j - <span class="number">1</span>] + <span class="number">1</span>,dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>);    </span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回最终状态：return dp[m] [n];</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">min3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> min(a, min(b, c));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = word1.size(), n = word2.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">      dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">      dp[<span class="number">0</span>][j] = j;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">          dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span>               </span><br><span class="line">          dp[i][j] = min3(</span><br><span class="line">            dp[i - <span class="number">1</span>][j] + <span class="number">1</span>,</span><br><span class="line">            dp[i][j - <span class="number">1</span>] + <span class="number">1</span>,</span><br><span class="line">            dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">          );</span><br><span class="line">    <span class="comment">// 储存着整个 s1 和 s2 的最小编辑距离</span></span><br><span class="line">    <span class="keyword">return</span> dp[m][n];      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode518. 零钱兑换 II</title>
      <link href="post/4f8ba50a.html"/>
      <url>post/4f8ba50a.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://mp.weixin.qq.com/s/zGJZpsGVMlk-Vc2PEY4RPw">公众号（labuladong），略有增删</a></strong></p><a id="more"></a><p><strong>这道题是完全背包问题的变体，和0-1背包问题的区别就是：完全背包问题里的物品能重复装入，而在0-1背包问题中，物品不能重复装入</strong></p><p><strong>我们可以把这个问题转化为背包问题的描述形式</strong>：</p><p>有一个背包，最大容量为<code>amount</code>，有一系列物品<code>coins</code>，每个物品的重量为<code>coins[i]</code>，<strong>每个物品的数量无限</strong>。请问有多少种方法，能够把背包恰好装满？</p><p><strong>虽然烦，但还是要写公式-_-||</strong></p><ol><li><p>状态：物品(变化量)：用下标i表示，背包容量，即可承受最大物品重量(变化量)：用下标j表示；dp数组含义：<strong>若只使用前i个物品，当背包容量为j时，有dp[i] [j]种方法可以装满背包</strong>。换句话说，翻译回我们题目的意思就是：<strong>若只使用coins中的前i个硬币的面值，若想凑出金额j，有dp[i] [j]种凑法</strong>。</p></li><li><p>最小状态：<code>dp[0][..] = 0， dp[..][0] = 1</code>。因为如果不使用任何硬币面值，就无法凑出任何金额；如果凑出的目标金额为 0，那么“无为而治”就是唯一的一种凑法。</p></li><li><p>状态转移方程(通过对状态的循环多次，有几个状态就有几层循环，对立相反的状态只需写两行代码即可，不需要循环)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)</span><br><span class="line">    <span class="keyword">if</span> (j - coins[i<span class="number">-1</span>] &gt;= <span class="number">0</span>)</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i<span class="number">-1</span>]];</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：这里和0-1背包问题的区别就在一处，我们来看下两者的区别</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0-1背包问题的状态转移方程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= W; w++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (w - wt[i<span class="number">-1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      dp[i][w] = dp[i - <span class="number">1</span>][w];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dp[i][w] = max(dp[i - <span class="number">1</span>][w - wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>], dp[i - <span class="number">1</span>][w]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>区别就在0-1背包问题中<code>dp[i - 1][w - wt[i-1]]</code>，而完全背包问题为<code>dp[i][j - coins[i-1]]</code>，因为完全背包问题能重复使用元素</strong></p></li><li><p>返回最终状态：<code>return dp[n][amount];</code></p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = coins.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][amount + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) </span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)</span><br><span class="line">            <span class="keyword">if</span> (j - coins[i<span class="number">-1</span>] &gt;= <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i<span class="number">-1</span>]];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amount];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode416. 分割等和子集</title>
      <link href="post/7b167e22.html"/>
      <url>post/7b167e22.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/0-1-bei-bao-wen-ti-bian-ti-zhi-zi-ji-fen-ge-by-lab/">Leetcode题解（labuladong），略有增删</a></strong></p><a id="more"></a><p>对于这个问题，看起来和背包没有任何关系，为什么说它是背包问题呢？</p><p>首先回忆一下背包问题大致的描述是什么：</p><p>给你一个可装载重量为<code>W</code>的背包和<code>N</code>个物品，每个物品有重量和价值两个属性。其中第<code>i</code>个物品的重量为<code>wt[i]</code>，价值为<code>val[i]</code>，现在让你用这个背包装物品，最多能装的价值是多少？</p><p>那么对于这个问题，我们可以先对集合求和，得出<code>sum</code>，把问题转化为背包问题：</p><p><strong>给一个可装载重量为sum/2的背包和N个物品，每个物品的重量为nums[i]。现在让你装物品，是否存在一种装法，能够恰好将背包装满</strong>？</p><p>你看，这就是背包问题的模型，甚至比我们之前的经典背包问题还要简单一些，<strong>下面我们就直接转换成背包问题</strong></p><p><strong>虽然烦，但还是要写公式-_-||</strong></p><ol><li><p>状态：数组元素(变化量)，用下标i来表示，元素和容量(变化量)，用下标j来表示；<code>dp[i][j] = x</code>表示，对于前<code>i</code>个物品，当前背包的容量为<code>j</code>时，若<code>x</code>为<code>true</code>，则说明可以恰好将背包装满，若<code>x</code>为<code>false</code>，则说明不能恰好将背包装满。比如说，如果<code>dp[4][9] = true</code>，其含义为：对于容量为 9 的背包，若只是用前 4 个物品，可以有一种方法把背包恰好装满。</p></li><li><p>最小状态：<code>dp[..][0] = true</code>和<code>dp[0][..] = false</code>，因为背包没有空间的时候，就相当于装满了，而当没有物品可选择的时候，肯定没办法装满背包。</p></li><li><p>状态转移方程(通过对状态的循环多次，有几个状态就有几层循环，对立相反的状态只需写两行代码即可，不需要循环)：<strong>两个状态，两次嵌套循环</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j - nums[i - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 背包容量不足，不能装入第 i 个物品</span></span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j]; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 装入或不装入背包</span></span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j] | dp[i - <span class="number">1</span>][j-nums[i<span class="number">-1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回最终状态：return <code>dp[N][sum/2]</code></p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line">        <span class="comment">// 和为奇数时，不可能划分成两个和相等的集合</span></span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        sum = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(sum + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - nums[i - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 背包容量不足，不能装入第 i 个物品</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]; </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 装入或不装入背包</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] | dp[i - <span class="number">1</span>][j-nums[i<span class="number">-1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0-1背包问题</title>
      <link href="post/72b23132.html"/>
      <url>post/72b23132.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://mp.weixin.qq.com/s/RXfnhSpVBmVneQjDSUSAVQ">公众号（labuladong），略有增删</a></strong></p><a id="more"></a><p>问题描述：给你一个可装载重量为<code>W</code>的背包和<code>N</code>个物品，每个物品有重量和价值两个属性。其中第<code>i</code>个物品的重量为<code>wt[i]</code>，价值为<code>val[i]</code>，现在让你用这个背包装物品，最多能装的价值是多少？</p><p>举个简单的例子，输入如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">3</span>, W = <span class="number">4</span></span><br><span class="line">wt = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">val = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>算法返回 6，选择前两件物品装进背包，总重量 3 小于<code>W</code>，可以获得最大价值 6。</p><p><strong>虽然烦，但还是要写公式-_-||</strong></p><ol><li><p>状态：物品(变化量)：用下标i表示，背包容量，即可承受最大物品重量(变化量)：用下标j表示；dp数组含义：dp[i] [w]表示对于前<code>i</code>个物品，当前背包的容量为<code>w</code>时，这种情况下可以装下的最大价值是<code>dp[i][w]</code>。</p></li><li><p>最小状态：<code>dp[0][w] = 0</code>：前0个物品装入容量为w的背包，其实就是有背包没物品，价值量为0；<code>dp[i][0] = 0</code>：前i个物品装入容量为0的背包，价值量自然也为0。这里其实可以简略处理，把全部元素都设为0<code>vector&lt;vector&lt;int&gt;&gt; dp(N + 1, vector&lt;int&gt;(W + 1, 0));</code></p></li><li><p>状态转移方程(通过对状态的循环多次，有几个状态就有几层循环，对立相反的状态只需写两行代码即可，不需要循环)：</p><p><strong>两个状态，循环嵌套两次</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= W; w++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (w - wt[i<span class="number">-1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 当前背包容量装不下，只能选择不装入背包</span></span><br><span class="line">      dp[i][w] = dp[i - <span class="number">1</span>][w];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 装入或者不装入背包，择优</span></span><br><span class="line">      dp[i][w] = max(dp[i - <span class="number">1</span>][w - wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>], dp[i - <span class="number">1</span>][w]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回最终状态：<code>return dp[N][W]</code>，表示前N个物品装入容量为W的背包里所获得的的最大价值量</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; wt, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// vector 全填入 0，base case 已初始化</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= W; w++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w - wt[i<span class="number">-1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前背包容量装不下，只能选择不装入背包</span></span><br><span class="line">                dp[i][w] = dp[i - <span class="number">1</span>][w];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 装入或者不装入背包，择优</span></span><br><span class="line">                dp[i][w] = max(dp[i - <span class="number">1</span>][w - wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>], dp[i - <span class="number">1</span>][w]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode516. 最长回文子序列</title>
      <link href="post/70dcc494.html"/>
      <url>post/70dcc494.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/solution/zi-xu-lie-wen-ti-tong-yong-si-lu-zui-chang-hui-wen/">Leetcode题解（labuladong），略有增删</a></strong></p><a id="more"></a><p><strong>虽然烦，但还是要写公式-_-||</strong></p><ol><li><p>状态：本道题完美契合设两个状态量，一个起始下标i，一个终止下标j，dp[i] [j]意思是以i起点，j为终点的子数组的最长回文子序列，因为<code>可以通过两侧的dp[i - 1] [j]和dp[i] [j - 1]推出dp[i] [j]</code></p></li><li><p>最小状态：dp[i] [i] = 1，每个元素自身都是回文子序列，因为i肯定小于等于j，所以对于那些i &gt; j的位置，根本不存在什么子序列，应该初始化为 0</p></li><li><p>状态转移方程(通过对状态的循环多次，有几个状态就有几层循环，对立相反的状态只需写两行代码即可，不需要循环)，<strong>还记得不能由未知推已知吗</strong></p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/1598019348294.png" alt="1598019348294"></p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两层嵌套循环以及注意状态元素的起始值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">    <span class="comment">// 状态转移方程，一次if判断</span></span><br><span class="line">    <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">      <span class="comment">// 它俩一定在最长回文子序列中</span></span><br><span class="line">      dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// s[i+1..j] 和 s[i..j-1] 谁的回文子序列更长？</span></span><br><span class="line">      dp[i][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>返回最终状态：<strong>return</strong> dp[0] [n - 1];   表示整个 s 的最长回文子串长度</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">          dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          dp[i][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode300. 最长上升子序列</title>
      <link href="post/dcbd00a3.html"/>
      <url>post/dcbd00a3.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-she-ji-fang-fa-zhi-pai-you-xi-jia/">Leetcode题解（labuladong），略有增删</a></strong></p><a id="more"></a><p>动态规划模板详见<a href="">Leetcode121-买卖股票的最佳时机</a></p><p><strong>虽然烦，但还是要写公式-_-||</strong></p><ol><li><p>状态(即下标)：数组元素下标(变化量)，<code>设为i</code>，意思是从数组下表0开始到数组下标i为止的最长上升子序列长度，<strong>至于说为什么不设两个状态量，一个起始下标i，一个终止下标j，dp[i] [j]意思是以i起点，j为终点的子数组的最长上升子序列，em…，因为</strong></p></li><li><p>最小状态：<code>dp[i] = 1</code>，因为第i个元素本身就能看成是一个上升元素</p></li><li><p>状态转移方程(通过对状态的循环多次，有几个状态就有几层循环，对立相反的状态只需写两行代码即可，不需要循环)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">      <span class="comment">// 下标为i的元素若比之前的任意一个元素大，上升子序列长度就+1</span></span><br><span class="line">      dp[i] = max(dp[i], <span class="number">1</span> + dp[j]);</span><br></pre></td></tr></table></figure><p><strong>这里需要注意一点，如果看过动态规划模板的话，可能会感到奇怪，不是说了有几个状态才有几个嵌套循环吗，为什么这里只有1个状态，却有两层循环。这是因为在模板文章里也说明了，在状态转移方程里是涉及到循环的，但这个循环却不是因为多出了一个状态而循环，比如这里的j元素最大才遍历到i，j的值受到i的制约，单纯是为了得出dp[i]所设出的下标，这种收其他状态影响的元素并不适合以上的<code>状态-循环</code>定理</strong></p></li><li><p>返回最终状态：和一般的返回<code>return dp[n - 1]</code>不同，因为我们状态转移方程书写的问题</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例子：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">6</span>]，nums[<span class="number">8</span>]和nums[<span class="number">6</span>]比较后无法进入<span class="keyword">if</span>体内，导致该次比较后的dp[<span class="number">8</span>]仍然为<span class="number">1</span></span><br><span class="line">最后的结果：dp[<span class="number">8</span>] == <span class="number">5</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)，而正确答案为最长上升序列长度为<span class="number">6</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.size() == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">          dp[i] = max(dp[i], <span class="number">1</span> + dp[j]);</span><br><span class="line">    <span class="keyword">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)</span><br><span class="line">      res = max(res, dp[i]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode3. 无重复字符的最长子串</title>
      <link href="post/4c0a5d16.html"/>
      <url>post/4c0a5d16.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/hua-dong-chuang-kou-tong-yong-si-xiang-jie-jue-zi-/">Leetcode题解（labuladong），略有增删</a></strong></p><a id="more"></a><p>滑动窗口模板详见<a href="">Leetcode76-最小覆盖子串</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 双指针问题</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; window;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">      <span class="keyword">char</span> c = s[right];</span><br><span class="line">      window[c]++;</span><br><span class="line">      right++;</span><br><span class="line">      <span class="comment">// 如果window中出现重复字符</span></span><br><span class="line">      <span class="comment">// 开始移动left缩小窗口</span></span><br><span class="line">      <span class="keyword">while</span> (window[c] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> d = s[left];</span><br><span class="line">        window[d]--;</span><br><span class="line">        left++;</span><br><span class="line">      &#125;</span><br><span class="line">      res = max(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这就是变简单了，连<code>need</code>和<code>valid</code>都不需要，而且更新窗口内数据也只需要简单的更新计数器<code>window</code>即可。</p><p>当<code>window[c]</code>值大于 1 时，说明窗口中存在重复字符，不符合条件，就该移动<code>left</code>缩小窗口了嘛。</p><p>唯一需要注意的是，在哪里更新结果<code>res</code>呢？我们要的是最长无重复子串，哪一个阶段可以保证窗口中的字符串是没有重复的呢？</p><p>这里和之前不一样，<strong>要在收缩窗口完成后更新res</strong>，因为窗口收缩的 while 条件是存在重复元素，换句话说收缩完成后一定保证窗口中没有重复嘛。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode438. 找到字符串中所有字母异位词</title>
      <link href="post/392579fe.html"/>
      <url>post/392579fe.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/hua-dong-chuang-kou-tong-yong-si-xiang-jie-jue-zi-/">Leetcode题解（labuladong），略有增删</a></strong></p><a id="more"></a><p>滑动窗口模板详见<a href="">Leetcode76-最小覆盖子串</a></p><p>这个所谓的字母异位词，不就是排列吗，搞个高端的说法就能糊弄人了吗？<strong>相当于，输入一个串S，一个串T，找到S中所有T的排列，返回它们的起始索引</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res; <span class="comment">// 记录结果</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[right];</span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.count(c)) &#123;</span><br><span class="line">                window[c]++;</span><br><span class="line">                <span class="keyword">if</span> (window[c] == need[c]) </span><br><span class="line">                    valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">            <span class="keyword">while</span> (right - left &gt;= t.size()) &#123;</span><br><span class="line">                <span class="comment">// 当窗口符合条件时，把起始索引加入 res</span></span><br><span class="line">                <span class="keyword">if</span> (valid == need.size())</span><br><span class="line">                    res.push_back(left);</span><br><span class="line">                <span class="keyword">char</span> d = s[left];</span><br><span class="line">                left++;</span><br><span class="line">                <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">                <span class="keyword">if</span> (need.count(d)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                        valid--;</span><br><span class="line">                    window[d]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode567. 字符串的排列</title>
      <link href="post/43b2fa2e.html"/>
      <url>post/43b2fa2e.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/permutation-in-string/solution/wo-xie-liao-yi-shou-shi-ba-suo-you-hua-dong-chuang/">Leetcode题解（labuladong），略有增删</a></strong></p><a id="more"></a><p>滑动窗口模板详见<a href="">Leetcode76-最小覆盖子串</a></p><p>对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变两个地方：</p><p><strong>1、</strong>本题移动<code>left</code>缩小窗口的时机是窗口大小大于<code>t.size()</code>时，因为排列嘛，显然长度应该是一样的。</p><p><strong>2、</strong>当发现<code>valid == need.size()</code>时，就说明窗口中就是一个合法的排列，所以立即返回<code>true</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 判断 s 中是否存在 t 的排列</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> t, <span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[right];</span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.count(c)) &#123;</span><br><span class="line">                window[c]++;</span><br><span class="line">                <span class="keyword">if</span> (window[c] == need[c])</span><br><span class="line">                    valid++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">            <span class="keyword">while</span> (right - left &gt;= t.size()) &#123;</span><br><span class="line">                <span class="comment">// 在这里判断是否找到了合法的子串</span></span><br><span class="line">                <span class="keyword">if</span> (valid == need.size())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">char</span> d = s[left];</span><br><span class="line">                left++;</span><br><span class="line">                <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">                <span class="keyword">if</span> (need.count(d)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                        valid--;</span><br><span class="line">                    window[d]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到符合条件的子串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode76. 最小覆盖子串</title>
      <link href="post/75953e30.html"/>
      <url>post/75953e30.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/minimum-window-substring/solution/hua-dong-chuang-kou-suan-fa-tong-yong-si-xiang-by-/">Leetcode题解（labuladong），略有增删</a></strong></p><a id="more"></a><p><strong>滑动窗口算法(也是快慢指针的一种类型，像一只蠕动的虫子)的代码框架</strong></p><p><strong>这里面有几个巧记点</strong></p><ol><li>滑动窗口，窗户的英文为window，所以需要一个window容器来存储</li><li>为什么need容器需要用map&lt;char, int&gt;来定义呢，因为子串中的字母不定全部不等，有可能出现aaaaaaaaa重复元素的情况，所以需要用map记录每个字符和它出现的次数</li><li>其中 valid 变量表示窗口中满足 need 条件的字符个数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新，一般来说就以下两条操作即可</span></span><br><span class="line">      <span class="comment">// 1. 判断字符c是否存在于s中，若要是window容器也容纳进该字符，若该字符已经存在于window容器内，则只需要把值再加1</span></span><br><span class="line">      <span class="comment">// 2. 如果window容器内某个字符满足need容器内的条件就让valid++</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩，也不一定非得是while，也可能是用if判断</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">          <span class="comment">// =======</span></span><br><span class="line">          <span class="comment">// 根据很多题的试验，发现跟题目相关的业务代码主要集中在这一块，其他部分几乎全部是一模一样复制粘贴的模板</span></span><br><span class="line">          <span class="comment">// =======</span></span><br><span class="line">          </span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">          <span class="comment">// 进行窗口内数据的一系列更新，一般来说就以下两条操作即可</span></span><br><span class="line">      <span class="comment">// 1. 判断字符d是否存在于s中，若要是window容器也删除该字符，若该字符已经存在于window容器内，则只需要把值再减1</span></span><br><span class="line">      <span class="comment">// 2. 如果window容器内某个字符满足need容器内的条件就让valid--，valid只需要减一次就行了</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>套模板时需要思考以下几个问题</strong></p><p>1、当移动 right 扩大窗口，即加入字符时，应该更新哪些数据？</p><p>2、什么条件下，窗口应该暂停扩大，开始移动 left 缩小窗口？</p><p>3、当移动 left 缩小窗口，即移出字符时，应该更新哪些数据？</p><p>4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？</p><p>如果一个字符进入窗口，应该增加 window 计数器；如果一个字符将移出窗口的时候，应该减少 window 计数器；当 valid 满足 need 时应该收缩窗口；应该在收缩窗口的时候更新最终结果。</p><h2 id="回到题目本身"><a href="#回到题目本身" class="headerlink" title="回到题目本身"></a>回到题目本身</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录最小覆盖子串的起始索引及长度</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, len = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">            <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> c = s[right];</span><br><span class="line">            <span class="comment">// 右移窗口</span></span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.count(c)) &#123;</span><br><span class="line">                window[c]++;</span><br><span class="line">                <span class="keyword">if</span> (window[c] == need[c])</span><br><span class="line">                    valid++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">            <span class="keyword">while</span> (valid == need.size()) &#123;</span><br><span class="line">                <span class="comment">// 在这里更新最小覆盖子串</span></span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; len) &#123;</span><br><span class="line">                    start = left;</span><br><span class="line">                    len = right - left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">                <span class="keyword">char</span> d = s[left];</span><br><span class="line">                <span class="comment">// 左移窗口</span></span><br><span class="line">                left++;</span><br><span class="line">                <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">                <span class="keyword">if</span> (need.count(d)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                        valid--;</span><br><span class="line">                    window[d]--;</span><br><span class="line">                &#125;                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最小覆盖子串</span></span><br><span class="line">        <span class="keyword">return</span> len == INT_MAX ?</span><br><span class="line">            <span class="string">&quot;&quot;</span> : s.substr(start, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode51. N皇后</title>
      <link href="post/4239f07a.html"/>
      <url>post/4239f07a.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/n-queens/solution/hui-su-suan-fa-xiang-jie-by-labuladong/">Leetcode题解（labuladong），略有增删</a></strong></p><a id="more"></a><p>回溯算法模板详见<a href="">Leetcode46-全排列</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 路径：board 中小于 row 的那些行都已经成功放置了皇后</span></span><br><span class="line">    <span class="comment">// 选择列表：第 row 行的所有列都是放置皇后的选择</span></span><br><span class="line">    <span class="comment">// 结束条件：row 超过 board 的最后一行</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 触发结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (row == board.size()) &#123;</span><br><span class="line">            res.push_back(board);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = board[row].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="comment">// 排除不合法选择</span></span><br><span class="line">            <span class="keyword">if</span> (!isValid(board, row, col)) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            <span class="comment">// 进入下一行决策</span></span><br><span class="line">            backtrack(board, row + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 是否可以在 board[row][col] 放置皇后？ */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.size();</span><br><span class="line">        <span class="comment">// 检查列是否有皇后互相冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][col] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查右上方是否有皇后互相冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; </span><br><span class="line">                i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查左上方是否有皇后互相冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>;</span><br><span class="line">                i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// &#x27;.&#x27; 表示空，&#x27;Q&#x27; 表示皇后，初始化空棋盘。</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">board</span><span class="params">(n, <span class="built_in">string</span>(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        backtrack(board, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode46. 全排列</title>
      <link href="post/15896e6d.html"/>
      <url>post/15896e6d.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/">Leetcode题解（labuladong），略有增删</a></strong></p><a id="more"></a><p><strong>解决一个回溯问题，实际上就是一个决策树的遍历过程</strong>。你只需要思考 3 个问题：</p><p>1、路径：也就是已经做出的选择。</p><p>2、选择列表：也就是你当前可以做的选择，这里提供一个获取选择列表的简易方法：<strong>只需要看题目最终要的到什么，然后去已知条件里看，能获得最终所要的答案的地方就是选择列表</strong>，说起来有点抽象，我们举几个例子</p><ul><li><a href="./Leetcode17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.md">Leetcode17. 电话号码的字母组合</a>：题目的输出为[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]，这些就是题目最终要得到的值，这些答案是<strong>字母</strong>的排列组合，所以<strong>选择列表必定是一串字母</strong>，那么我们去题干里看，如何才能获得<strong>字母</strong>？结果是通过手机号码<strong>数字</strong>，相当于下标去获得<strong>字母串</strong></li><li>针对本题全排列来说：输出为[[1,2,3], [1,3,2]….]，这些答案是<strong>数字</strong>的排列组合，所以<strong>选择列表必定是一串数字</strong>，那么我们去题干里看，如何才能获得<strong>数字</strong>？因为题干提供的本身就是数字，我们直接拿题干当选择列表即可。</li></ul><p>3、剪枝：如果有必要的话，在选择列表里的某几个选择是无法使用的，此时就需要把这些选择<strong>排除在外</strong></p><ul><li>就比如这道全排列题，数组里的每个元素只能用一次，所以使用<code>visited</code>数组用来标记是否需要排除。<strong>在第一次处理该选择之后排除该选择，同时别忘了在取消选择的时候再把这个被排除的选择包含进来</strong></li></ul><p>4、结束条件：也就是到达决策树底层，无法再做选择的条件。</p><p>代码方面，回溯算法的框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">路径, 选择列表</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p><strong>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」</strong>，特别简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// 记录「路径」</span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();`</span><br><span class="line"> <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    backtrack(res, nums, track, visited);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径：记录在 track 中</span></span><br><span class="line"><span class="comment">// 选择列表：nums 中不存在于 track 的那些元素</span></span><br><span class="line"><span class="comment">// 结束条件：nums 中的元素全都在 track 中出现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择，即剪枝</span></span><br><span class="line">      <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">      visited[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(res, nums, track, visited);</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">      visited[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode121. 买卖股票的最佳时机</title>
      <link href="post/2e315490.html"/>
      <url>post/2e315490.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/">Leetcode题解（labuladong），略有增删</a></strong></p><a id="more"></a><h3 id="动态规划N步骤"><a href="#动态规划N步骤" class="headerlink" title="动态规划N步骤"></a>动态规划N步骤</h3><ol><li><p>明确题目中的<code>状态</code>，以及该状态对应的含义dp数组含义；如何寻找状态？</p><ul><li>变化量(值会变化的)</li><li>对立相反量(买入/卖出，左/右，做/不做….)，因为容易给dp数组定义下标：dp[0]，dp[1]。也就两个下标</li><li><strong>明确一点，状态即下标！状态即下标！状态即下标</strong>，状态选择是什么，那么dp数组的下标需要以这个状态为标准进行设置。比如状态若为源数组的下标，那么dp数组的下标就为dp[1,2,3,4,5…..]；如果状态为对立相反的量，那么dp数组的下标就只有dp[0]和dp[1]</li></ul></li><li><p>根据状态明确<code>最小子问题</code>，简而言之就是<code>寻找最容易想到的值</code>，<strong>而且如果有<code>无限多个</code>最小子问题时，必须是一个和状态量无关的定值，即不管状态量为什么，最小子问题的值始终固定</strong></p><ul><li>比如求数组里的最长子序列：每个元素本身就是一个子序列，如果用<strong>dp[i] [j]</strong> 代表数组从i到j的最长子序列，则<strong>dp[i] [i] = 1</strong>，这个问题存在着多个最小子问题，但是dp[i] [i]的值始终为1，所以这个最小子问题值是符合条件的</li><li>再比如<a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍问题</a>：如果把<strong>dp[i]</strong> 定义成前<strong>i</strong>间最大偷取钱数，则<strong>dp[0]</strong> 表示前0间最大偷取的钱，可不就是0吗；则<strong>dp[1]</strong> 表示前1间最大偷取的钱，可不就是nums[0]吗</li><li>。。。。</li></ul></li><li><p>列出状态转移方程，<strong>一定，一定，一定会用到多次循环，这是针对状态进行的循环，有多少个状态就有多少层嵌套循环(比如针对状态i从0循环到n，针对状态j从i+1循环到n，针对状态k从n循环到0……，每层循环的次数根据该状态有几种不同的值来决定，其中类似于对立相反的状态一般只需要写两行代码就好了dp[i] [0] = ?和dp[i] [1] = ?，不需要循环，有超出2个以上的状态值的话使用循环，但是具体问题还是要具体分析)</strong> ：<strong>这一步是最困难的，可能涉及到多次if条件判断, 循环等等，请耐心读题；但是如果状态设置的好，那么转移方程也好列出</strong>。</p><ul><li><p>还需要注意一点的是一定是某几个<code>点</code>概念的值进行判断比较，比如对于时间比较而言，我要比较的是<code>时刻</code>这个点概念值的大小，而不是比较时间这个<code>范围</code>概念的值的大小；比如dp数组的意义若为<code>前i</code>个数组值怎么怎么样，那么在进行状态转移的时候比较的永远是<strong>给定数组</strong>的<code>第i</code>个数组值进行比较。类似于nums是给定数组，然后状态转移判断时采用<code>if(nums[i - 1] &gt;= nums[i])</code>，<strong>进行<code>if条件判断</code>的是题目给定数组，而方程转移的是dp数组</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比的是点，变的是线(一维dp数组)或者面(二维dp数组)或者三,四维dp数组.....</span></span><br><span class="line"><span class="keyword">if</span>(nums[i - <span class="number">1</span>] &gt;= nums[i])&#123;</span><br><span class="line">  dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>且一般都是从下标<code>i - 2, i - 1, i, i + 1, j - 2, j - 1, j , j + 1,j + 2.....</code>等下标入手，<strong>你要想想dp[i] [j]要怎么和上述的几个下标元素内容发生关系</strong>。但这也不是完全契合部分题目，下标的选择还是要看状态如何设置，毕竟<strong>状态即下标</strong>，比如背包问题中，其中一个状态为背包容量，那么<code>dp数组下标</code>就是背包容量，下标的变化也就成了<code>dp[i-1][j-nums[i]]</code></p></li></ul></li></ol><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/1597994643272.png" alt="1597994643272"></p><ul><li><p><strong>第三步的时候一定要注意一点</strong>：<code>必须用已知推未知, 不能用未知推已知</code></p><ul><li>如果已知左下三个元素的值，就<strong>只能</strong>通过左下三个值推nums[i] [j]</li></ul><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/1597995598006.png" alt="1597995598006"></p><ul><li>如果已知右上三个元素的值，就<strong>只能</strong>通过右上三个值推nums[i] [j]，</li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/1597995658004.png" alt="1597995658004"></p><ol start="4"><li>明确最终状态并且返回。如果说第二步是明确其中一个极端的话(什么都不做)，那么这步就是明确另一个极端(做完了)。对应在下标的表示上<ul><li>比如初始状态是dp[0]的话，那么最终状态就是dp[n]</li><li>比如初始状态是dp[0] [0]的话，那么最终状态就是dp[n] [m]</li><li>…..</li></ul></li></ol><h3 id="给自己定个小目标：每做一道动态规划题都先用使用公式，把每道题的条件填入公式里"><a href="#给自己定个小目标：每做一道动态规划题都先用使用公式，把每道题的条件填入公式里" class="headerlink" title="给自己定个小目标：每做一道动态规划题都先用使用公式，把每道题的条件填入公式里"></a>给自己定个小目标：每做一道动态规划题都先用使用公式，把每道题的条件填入公式里</h3><p>公式：</p><ol><li>状态：A ，B，C….，N个状态的组合对应着什么值</li><li>最小状态：dp[i] = … 或者 dp[i] [0] = …..或者其他</li><li>状态转移方程(通过对状态的循环多次，有几个状态就有几层循环，对立相反的状态只需写两行代码即可，不需要循环)：dp[i] = dp[i - 1] + 1或者其他</li><li>返回最终状态：return dp[n]；或者其他</li></ol><h3 id="那么回到本道题"><a href="#那么回到本道题" class="headerlink" title="那么回到本道题"></a>那么回到本道题</h3><ol><li><p>状态：天数(可变值)，持有股票与否(对立的一对值)，这两个状态对应的含义为第i天时，是否持有股票，然后前i天<strong>最多</strong>赚了多少钱</p></li><li><p>最小状态：</p><ul><li>dp[1] [0] = 0：第1天，没持有股票，一分钱没赚找</li><li>dp[1] [1] = 0 - prices[i]：第1天，持有股票，因为买了第一天的股票，所以亏了prices[i]那么多的钱</li></ul></li><li><p>状态转移方程(<strong>该题有两个状态，其中一个是对立相反的状态，所以只需要一层循环+每层循环两行代码即可</strong>)：</p><ul><li><strong>dp[i] [0] = max(dp[i - 1] [0]，dp[i - 1] [1] + prices[i - 1])</strong> ：第i天没有持有股票要么就是昨天没持有，今天也没持有；要么就是昨天买入股票持有，但是今天卖了(<strong>注：这里的prices[i - 1]表示第i天的价格，dp[i] [0]表示前i天，比如前1天就表示prices[0]，注意两者的区别与联系</strong>)</li><li><strong>dp[i] [1] = max(dp[i - 1] [1]，dp[i - 1] [0] - prices[i - 1])</strong> ：第i天持有股票要么就是昨天也持有，今天也持有；要么就是昨天没持有，但是今天买入股票变成持有了</li></ul></li><li><p>返回最终状态：return dp[n] [0]；意味第n天没持有股票，然后然后前n天<strong>最多</strong>赚了多少钱</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span> - prices[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">          dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>]);</span><br><span class="line">           <span class="comment">// 这里是0 - prices[i - 1]，而不是dp[i - 1][0] - prices[i]的原因是只进行一次交易</span></span><br><span class="line">        <span class="comment">// 如果状态是dp[i][1]的话，则表示之前就没有买入过股票，而只能进行一次交易，所以就是0 - prices[i - 1]</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], <span class="number">0</span> - prices[i - <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-Leetcode123-买卖股票的最佳时机-III"><a href="#2-Leetcode123-买卖股票的最佳时机-III" class="headerlink" title="2. Leetcode123. 买卖股票的最佳时机 III"></a>2. Leetcode123. 买卖股票的最佳时机 III</h2><p>这道题又多了一个状态：最大交易次数；让我们复习一下，多了一个状态意味着多了一个状态下标，意味着多了一层状态循环。我们暂且把这个状态的下标定为k</p><ol><li><p>状态转移方程没有可以简化的地方，就是在原有的基础上加上k这个元素下标</p><p>dp[i] [k] [0] = max(dp[i - 1] [k] [0]，dp[i - 1] [k] [1] + prices[i - 1])</p><p>dp[i] [k] [1] = max(dp[i - 1] [k] [1]，dp[i - 1] [k - 1] [0] - prices[i - 1])</p></li><li><p>最小状态</p><ul><li>当k==1时，也就是前面一题的情况，dp[1] [1] [0] = 0，dp[1] [1] [1] = 0 - prices[0]</li><li>当k==2时，其实仔细想一想也就是和k==1同一个初始条件，我就一天你还能交易两次？</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_k = <span class="number">2</span>, n = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> [][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][max_k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = max_k; k &gt;= <span class="number">1</span>; k--)&#123;</span><br><span class="line">            dp[<span class="number">1</span>][k][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[<span class="number">1</span>][k][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = max_k; k &gt;= <span class="number">1</span>; k--)&#123;</span><br><span class="line">                dp[i][k][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">0</span>], dp[i - <span class="number">1</span>][k][<span class="number">1</span>] + prices[i - <span class="number">1</span>]);</span><br><span class="line">                dp[i][k][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">1</span>], dp[i - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][max_k][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Leetcode122-买卖股票的最佳时机-II"><a href="#3-Leetcode122-买卖股票的最佳时机-II" class="headerlink" title="3. Leetcode122. 买卖股票的最佳时机 II"></a>3. Leetcode122. 买卖股票的最佳时机 II</h2><ul><li><p>状态转移方程没有可以简化的地方，就是在原有的基础上加上k这个元素下标</p><p>​    dp[i] [k] [0] = max(dp[i - 1] [k] [0]，dp[i - 1] [k] [1] + prices[i - 1])</p><p>​    dp[i] [k] [1] = max(dp[i - 1] [k] [1]，dp[i - 1] [k - 1] [0] - prices[i - 1])</p></li><li><p>只不过k为无穷大，那么就可以认为 k 和 k - 1 是一样的，跟k == 1时的情况一模一样，代码也是一模一样</p><p>​    dp[i] [0] = max(dp[i - 1] [0], dp[i - 1] [1] + prices[i - 1]);</p><p>​    dp[i] [1] = max(dp[i - 1] [1], dp[i - 1] [0] - prices[i  - 1]);</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>]);</span><br><span class="line">          <span class="comment">// 跟k==1时的情况一模一样</span></span><br><span class="line">          <span class="comment">// 除了因为没有次数限制，从0 - prices[i - 1]变为了dp[i - 1][0] -prices[i - 1]之外</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] -prices[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-Leetcode714-买卖股票的最佳时机含手续费"><a href="#4-Leetcode714-买卖股票的最佳时机含手续费" class="headerlink" title="4. Leetcode714. 买卖股票的最佳时机含手续费"></a>4. Leetcode714. 买卖股票的最佳时机含手续费</h2><p>换汤不换药，就是在卖出股票的时候再花费一笔手续费</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>] - fee;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>]);</span><br><span class="line">      dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>] - fee);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-Leetcode309-最佳买卖股票时机含冷冻期"><a href="#5-Leetcode309-最佳买卖股票时机含冷冻期" class="headerlink" title="5. Leetcode309. 最佳买卖股票时机含冷冻期"></a>5. Leetcode309. 最佳买卖股票时机含冷冻期</h2><p>就是类似于打家劫舍问题里的隔一天再买，涉及到<code>i - 2</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">        dp[<span class="number">2</span>][<span class="number">0</span>] = max(prices[<span class="number">1</span>] - prices[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">2</span>][<span class="number">1</span>] = max(-prices[<span class="number">0</span>], -prices[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>]);</span><br><span class="line">      dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">2</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode面试题 01.06. 字符串压缩</title>
      <link href="post/50df684c.html"/>
      <url>post/50df684c.html</url>
      
        <content type="html"><![CDATA[<p>原创</p><a id="more"></a><p><strong>双指针分为<code>快慢双指针和前后双指针</code>，这里为快慢双指针，索引j用作不断向前探索与s[i]相同的元素，直到不相同，则记录下标，并且与i相减获得相同数组元素个数；以此循环往复</strong></p><p><strong>这里复习一下<a href="E:\code\hexo-site\blog\source_posts\Leetcode58-最后一个单词的长度.md">Leetcode58-最后一个单词的长度</a>有关循环的技巧</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">compressString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">            res.append(s.charAt(<span class="number">0</span>) + <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; len &amp;&amp; j &lt;= len)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == len || s.charAt(i) != s.charAt(j))&#123;</span><br><span class="line">                    res.append(s.charAt(i));</span><br><span class="line">                    res.append(j - i);</span><br><span class="line">                    i = j;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.toString().length() &gt;= len? s:res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode98. 验证二叉搜索树</title>
      <link href="post/8ff141d0.html"/>
      <url>post/8ff141d0.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/bao-zhun-sheng-guo-guan-fang-ti-jie-by-novice2mast/">Leetcode题解（Novice2Master），略有增删</a></strong></p><a id="more"></a><h4 id="方法一（简单但错误的方法）"><a href="#方法一（简单但错误的方法）" class="headerlink" title="方法一（简单但错误的方法）"></a>方法一（简单但错误的方法）</h4><p>最简单的方式就是对每一个顶点，判断其左孩子是不是比它小，左孩子是否比它大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(struct TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( root == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>( root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;val &gt; root-&gt;val ) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>( root-&gt;right != <span class="literal">NULL</span> &amp;&amp; root-&gt;right-&gt;val &lt; root-&gt;val ) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>( !isValidBST(root-&gt;left) || !isValidBST(root-&gt;right) ) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种解法的问题出在：二叉排序树的性质是一个节点的<strong>左右子树而不是左右孩子节点</strong></p><p><img src= "/img/loading.gif" data-lazy-src="./Leetcode98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/1597981146152.png" alt="1597981146152"></p><p>上图中的根结点是 6 ，而其左子树中的结点 7 大于 6 ，显然不符合二叉排序树的定义；右子树当中的结点 1 小于根结点 6，同样是不合理的；但是你发现上面程序会返回 true，因为上面的程序仅检查了一个结点的左孩子和右孩子，我们自然想到检查一个的结点左子树当中的最大顶点是否比结点小，右子树当中值最小的顶点是否比结点大不就好了，比如根结点 6 的左子树当中最大的顶点为 7 大于 6 ，所以不是一颗二叉排序树，返回false;</p><h4 id="方法二（正确但并不高效）"><a href="#方法二（正确但并不高效）" class="headerlink" title="方法二（正确但并不高效）"></a>方法二（正确但并不高效）</h4><p>对于每一个结点，检查结点左子树中值最大的结点的值是否小于结点，右子树中值最小的结点是否大于结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minValueNode</span><span class="params">(struct TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">current</span> =</span> node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*从删除结点的右孩子开始一直向左走，找到最小值*/</span></span><br><span class="line">        <span class="keyword">while</span> (current &amp;&amp; current-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> current-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回删除结点左子树当中的值最大的结点指针 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValueNode</span><span class="params">(struct TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">current</span> =</span> node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*从删除结点的右孩子开始一直向左走，找到最小值*/</span></span><br><span class="line">        <span class="keyword">while</span> (current &amp;&amp; current-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            current = current-&gt;right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> current-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(struct TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 分</span></span><br><span class="line">      <span class="keyword">if</span>(!isValidBST(root-&gt;left) || !isValidBST(root-&gt;right)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 治</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span> &amp;&amp; maxValueNode(root-&gt;left) &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span> &amp;&amp; minValueNode(root-&gt;right) &lt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注：这里提一点递归和分而治之的联系与区别</strong></p><ul><li><p>递归策略分为（减而治之和分而治之）</p></li><li><p>减而治之就是俗称的递归：求解一个大规模的问题，可以将其划分为两个子问题，其一是平凡问题，另一个规模缩减。由子问题的解，得到原问题的解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">1</span>)?<span class="number">0</span>:A[n-<span class="number">1</span>]+sum(A,n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分而治之：求解一个大规模的问题，可以将其划分为多个（通常情况下为两个）子问题，两个问题的规模大体相同。由子问题的解，得到原问题的解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (low == high) ? </span><br><span class="line">  A[low] : sum(A, low, (low + high) &gt;&gt; <span class="number">1</span>) + sum(A, ((low + high) &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分而治之简单来讲分为两个角度，三个步骤</p><ol><li><p>分</p><ol><li><p>确定分到最小单元要做的操作，也就是俗称的递归终止条件，简而言之就是在你脑子里<code>最容易想到</code>的一种操作情况，<strong>比如让你去区分一颗树是不是二分搜索树，当一棵树为空树的时候就是一颗最简单的二分搜索树</strong>，这种情况是最容易想到的，即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root == NULL) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用递归模板去<code>分</code>，但在写递归模板的时候，<code>函数的参数要和总函数一致，即函数思想要一致</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isValidBST(root-&gt;left)</span><br><span class="line">isValidBST(root-&gt;right)</span><br></pre></td></tr></table></figure></li></ol></li><li><p>治：建立分和总之间的联系，由分推总(<strong>这部分的代码是最难想的，是涉及到具体的代码判断，赋值等操作的</strong>)。<strong>既然分和总函数有着同样的思想</strong>，那么两者函数的参数和返回值均相同，分函数的返回值为bool，那么总函数的返回值也是bool；即分函数是判断一颗子树是不是二叉搜索树，那么总函数也是判断一颗树是不是二叉搜索树。那么如何判断呢？<strong>找到左子树的最大值和右子树的最小值，然后跟根节点数值进行比较，这就是具体的代码判断赋值操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找左子树最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minValueNode</span><span class="params">(struct TreeNode* node)</span> </span>&#123;</span><br><span class="line">    struct TreeNode* current = node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*从删除结点的右孩子开始一直向左走，找到最小值*/</span></span><br><span class="line">    <span class="keyword">while</span> (current &amp;&amp; current-&gt;left != NULL)</span><br><span class="line">      current = current-&gt;left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找右子树最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxValueNode</span><span class="params">(struct TreeNode* node)</span> </span>&#123;</span><br><span class="line">    struct TreeNode* current = node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*从删除结点的右孩子开始一直向左走，找到最小值*/</span></span><br><span class="line">    <span class="keyword">while</span> (current &amp;&amp; current-&gt;right != NULL)</span><br><span class="line">      current = current-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跟根节点数值进行比较</span></span><br><span class="line"><span class="keyword">if</span>(root-&gt;left != NULL &amp;&amp; maxValueNode(root-&gt;left) &gt;= root-&gt;val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;right != NULL &amp;&amp; minValueNode(root-&gt;right) &lt;= root-&gt;val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 分而治之 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode215. 数组中的第K个最大元素</title>
      <link href="post/2e4c4b4c.html"/>
      <url>post/2e4c4b4c.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/">Leetcode题解（liweiwei1419），略有增删</a></strong></p><a id="more"></a><p>题目要求我们找到“数组排序后的第 kk 个最大的元素，而不是第 kk 个不同的元素” ，</p><p>语义是从右边往左边数第 kk 个元素（从 11 开始），那么从左向右数是第几个呢，我们列出几个找找规律就好了。</p><p>一共 6 个元素，找第 2 大，索引是 4；<br>一共 6 个元素，找第 4 大，索引是 2。<br>因此，升序排序以后，<strong>目标元素的索引是 len - k</strong>。</p><h3 id="方法一：暴力解法"><a href="#方法一：暴力解法" class="headerlink" title="方法一：暴力解法"></a>方法一：暴力解法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        sort(begin(nums), end(nums));</span><br><span class="line">        <span class="keyword">return</span> nums[size - k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二：借助-partition-操作定位到最终排定以后索引为-len-k-的那个元素"><a href="#方法二：借助-partition-操作定位到最终排定以后索引为-len-k-的那个元素" class="headerlink" title="方法二：借助 partition 操作定位到最终排定以后索引为 len - k 的那个元素"></a>方法二：借助 partition 操作定位到最终排定以后索引为 <code>len - k</code> 的那个元素</h3><p><strong>快速排序里的partition操作每次都能把一个元素固定在它最后存在的那个位置，我们只需要使用到这个性质定位到len-k这个位置即可，没必要把数组变成有序，不需把快排的全部代码粘过来</strong></p><p>主函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换一下，第 k 大元素的索引是 len - k</span></span><br><span class="line">    <span class="keyword">int</span> target = len - k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = partition(nums, left, right);</span><br><span class="line">        <span class="keyword">if</span> (index == target) &#123;</span><br><span class="line">          <span class="keyword">return</span> nums[index];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; target) &#123;</span><br><span class="line">          left = index + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          right = index - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序的主函数，<strong>可以看到还是由很大不同的，但是partition部分代码是完全一致的</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">      <span class="keyword">int</span> index = partition(nums, low, high);</span><br><span class="line">      QuickSort(nums, low, index - <span class="number">1</span>);</span><br><span class="line">      QuickSort(nums, index + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全部代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换一下，第 k 大元素的索引是 len - k</span></span><br><span class="line">        <span class="keyword">int</span> target = len - k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="comment">// 分而治之</span></span><br><span class="line">            <span class="keyword">int</span> index = partition(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span> (index == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[index];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; target) &#123;</span><br><span class="line">                left = index + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = index - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">          <span class="comment">// 将比pivot小的元素移动到左边</span></span><br><span class="line">          <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] &gt;= pivot) right--;</span><br><span class="line">          nums[left] = nums[right];</span><br><span class="line">          <span class="comment">// 将比pivot大的元素移动到右边</span></span><br><span class="line">          <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] &lt;= pivot) left++;</span><br><span class="line">          nums[right] = nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">      nums[left] = pivot; <span class="comment">// 最后将pivot放在最后的那个位置</span></span><br><span class="line">      <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三：优先队列"><a href="#方法三：优先队列" class="headerlink" title="方法三：优先队列"></a>方法三：优先队列</h3><p>方法论详见<a href="./Leetcode%E5%89%91%E6%8C%87-Offer-40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.md">Leetcode剑指-Offer-40-最小的k个数</a></p><ul><li>使用全部<code>len</code>个容量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 使用一个含有 len 个元素的最小堆，默认是最小堆，可以不写 lambda 表达式：(a, b) -&gt; a - b</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(len, (a, b) -&gt; a - b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            minHeap.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - k; i++) &#123;</span><br><span class="line">            minHeap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只用 <code>k</code> 个容量的优先队列，而不用全部 <code>len</code> 个容量。<ul><li>我要的是k个最大元素中的最小值，所以用小根堆</li><li>我要的是k个最大的元素，所以最小的len-k个元素全部滚出去！！小值元素出队同样能印证使用小根堆的正确性，因为只有最小的元素才能在队头出队</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 使用一个含有 k 个元素的最小堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, (a, b) -&gt; a - b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            minHeap.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 看一眼，不拿出，因为有可能没有必要替换</span></span><br><span class="line">            Integer topEle = minHeap.peek();</span><br><span class="line">            <span class="comment">// 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; topEle) &#123;</span><br><span class="line">                minHeap.poll();</span><br><span class="line">                minHeap.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分而治之 </tag>
            
            <tag> 快速排序 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode剑指 Offer 40. 最小的k个数</title>
      <link href="post/ecb11406.html"/>
      <url>post/ecb11406.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou/">Leetcode题解（Sweetiee），略有增删</a></strong></p><a id="more"></a><p>大根堆(前 K 小) / 小根堆（前 K 大),Java，C++中有现成的 PriorityQueue，实现起来最简单</p><p><strong>注：本题是求前 K 小，因此维护一个容量为 K 的大根堆，每次 poll 出最大的数，那堆中保留的就是前 K 小啦（注意不是小根堆！小根堆的话需要把全部的元素都入堆，那是 O(NlogN)O(NlogN)😂，就不是 O(NlogK)O(NlogK)啦～～）</strong></p><ul><li>每次 poll 出最大的数只能使用大根堆，因为只有队头才能出队，同样能印证使用大根堆的正确性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保持堆的大小为K，然后遍历数组中的数字，遍历的时候做如下判断：</span></span><br><span class="line"><span class="comment">// 1. 若目前堆的大小小于K，将当前数字放入堆中。</span></span><br><span class="line"><span class="comment">// 2. 否则判断当前数字与大根堆堆顶元素的大小关系，如果当前数字比大根堆堆顶还大，这个数就直接跳过；</span></span><br><span class="line"><span class="comment">//    反之如果当前数字比大根堆堆顶小，先poll掉堆顶，再将该数字放入堆中。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 默认是小根堆，实现大根堆需要重写一下比较器。</span></span><br><span class="line">        Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &lt; k) &#123;</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; pq.peek()) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回堆中的元素</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[pq.size()];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: pq) &#123;</span><br><span class="line">            res[idx++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode125. 验证回文串</title>
      <link href="post/e4078e0d.html"/>
      <url>post/e4078e0d.html</url>
      
        <content type="html"><![CDATA[<p><strong>注：答案因为字符和数字判断方面有错，但是思想是对的，通多两端双指针的方式不断向内部逼近，通过循环中的循环方式移除所有非数字非字母元素</strong></p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isalpha</span><span class="params">(<span class="keyword">char</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((a &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; a &lt;= <span class="string">&#x27;z&#x27;</span>) || (a &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; a &lt;= <span class="string">&#x27;Z&#x27;</span>))? <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="built_in">isalpha</span>(s[i]) || <span class="built_in">isdigit</span>(s[i])) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!(<span class="built_in">isalpha</span>(s[i]) || <span class="built_in">isdigit</span>(s[i]))) i++;</span><br><span class="line">            <span class="keyword">while</span>(!(<span class="built_in">isalpha</span>(s[j]) || <span class="built_in">isdigit</span>(s[j]))) j--;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">tolower</span>(s[i++]) != <span class="built_in">tolower</span>(s[j--])) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == j? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode67. 二进制求和</title>
      <link href="post/323e9a8b.html"/>
      <url>post/323e9a8b.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/add-binary/solution/hua-jie-suan-fa-67-er-jin-zhi-qiu-he-by-guanpengch/">Leetcode题解（画手大鹏），略有增删</a></strong></p><a id="more"></a><p>双指针同时从末尾进行遍历计算，得到最终结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>, i = a.length() - <span class="number">1</span>, j = b.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = carry;</span><br><span class="line">            sum += i &gt;= <span class="number">0</span> ? a.charAt(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            sum += j &gt;= <span class="number">0</span> ? b.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            ans.append(sum % <span class="number">2</span>);</span><br><span class="line">            carry = sum / <span class="number">2</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.append(carry == <span class="number">1</span> ? carry : <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ans.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leecode994. 腐烂的橘子</title>
      <link href="post/dd7258b1.html"/>
      <url>post/dd7258b1.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/rotting-oranges/solution/li-qing-si-lu-wei-shi-yao-yong-bfsyi-ji-ru-he-xie-/">Leetcode题解（nettee），略有增删</a></strong></p><a id="more"></a><p>BFS 可以看成是层序遍历。从某个结点出发，BFS 首先遍历到距离为 1 的结点，然后是距离为 2、3、4…… 的结点。因此，BFS 可以用来求<strong>最短路径问题</strong>。BFS 先搜索到的结点，一定是距离最近的结点。</p><p>再看看这道题的题目要求：返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。翻译一下，实际上就是<strong>求腐烂橘子到所有新鲜橘子的最短路径</strong>。那么这道题使用 BFS，应该是毫无疑问的了。</p><p>BFS两个模板详见**<a href="E:\code\hexo-site\blog\source_posts\Leetcode102-二叉树的层序遍历.md">Leetcode102</a><strong>，区分使用两个模板的条件为</strong>是否需要一口气处理完某一次循环中在队列里的全部 n 个结点**</p><p>有了计算最短路径的层序 BFS 代码框架，写这道题就很简单了。这道题的主要思路是：</p><ul><li>一开始，我们找出所有腐烂的橘子，将它们放入队列，作为第 0 层的结点。</li><li>然后进行 BFS 遍历，每个结点的相邻结点可能是上、下、左、右四个方向的结点，注意判断结点位于网格边界的特殊情况。</li><li>由于可能存在无法被污染的橘子，我们需要记录新鲜橘子的数量。在 BFS 中，每遍历到一个橘子（污染了一个橘子），就将新鲜橘子的数量减一。如果 BFS 结束后这个数量仍未减为零，说明存在无法被污染的橘子。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>, fresh = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++)</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>) fresh++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j] == <span class="number">2</span>) q.push(&#123;i, j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; dirs = &#123; &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125; &#125;;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = q.size();</span><br><span class="line">            <span class="keyword">bool</span> rotten = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> cur: dirs) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = x.first + cur.first;</span><br><span class="line">                    <span class="keyword">int</span> j = x.second + cur.second;</span><br><span class="line">                    <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; grid.size() &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; grid[<span class="number">0</span>].size() &amp;&amp; grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                        grid[i][j] = <span class="number">2</span>;</span><br><span class="line">                        q.push(&#123;i, j&#125;);</span><br><span class="line">                        fresh--;</span><br><span class="line">                        rotten = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rotten) min++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> fresh ? <span class="number">-1</span> : min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode58. 最后一个单词的长度</title>
      <link href="post/210a93b5.html"/>
      <url>post/210a93b5.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/length-of-last-word/solution/hua-jie-suan-fa-58-zui-hou-yi-ge-dan-ci-de-chang-d/">Leetcode题解（画手大鹏），略有增删</a></strong></p><a id="more"></a><p>标签：字符串遍历<br>从字符串末尾开始向前遍历，其中主要有两种情况</p><ol><li><p>第一种情况，以字符串”Hello World”为例，从后向前遍历直到遍历到头或者遇到空格为止，即为最后一个单词”World”的长度</p></li><li><p>第二种情况，以字符串”Hello World “为例，需要先将末尾的空格过滤掉，再进行第一种情况的操作，即认为最后一个单词为”World”，长度为5</p></li><li><p>所以完整过程为先从后过滤掉空格找到单词尾部，再从尾部向前遍历，找到单词头部，最后两者相减，即为单词的长度时间复杂度：O(n)，n为结尾空格和结尾单词总体长度</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> end = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &gt;= <span class="number">0</span> &amp;&amp; s.charAt(end) == <span class="string">&#x27; &#x27;</span>) end--;</span><br><span class="line">        <span class="keyword">if</span>(end &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = end;</span><br><span class="line">        <span class="keyword">while</span>(start &gt;= <span class="number">0</span> &amp;&amp; s.charAt(start) != <span class="string">&#x27; &#x27;</span>) start--;</span><br><span class="line">        <span class="keyword">return</span> end - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里对循环条件多说几句：</strong></p><ol><li><p>明确跳出循环的条件，比如这题循环是为了获得非空字符，那么循环条件就是空字符<code>s.charAt(end) == &#39; &#39;</code>，同时循环还不能使数组越界<code>end &gt;= 0</code>。<code>即我为了获得一个东西，把循环条件置成不能获得这个东西的条件</code></p></li><li><p>根据<strong>每一个</strong>循环条件判断循环之后要干什么，当不满足<code>end&gt;=0</code>这个循环条件时，跳出循环的时候则表示这串字符就是空字符串了，则<code>if(end &lt; 0) return 0</code>；若不满足<code>s.charAt(end) == &#39; &#39;</code>就表示已经排除掉了所有空字符，可以进行下一步操作了</p></li><li><p>把第一个条件再次运用一遍：我为了获取空字符，从而把循环条件置成不能获得空字符的条件，即<code>s.charAt(start) != &#39; &#39;</code></p></li><li><p>如果循环的条件为多个且是<code>或</code>的关系，则需要在循环体内对条件进行判断处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(i &lt; <span class="number">0</span>) ...</span><br><span class="line">     <span class="keyword">if</span>(j &lt; <span class="number">0</span>) ...</span><br><span class="line">  i--;</span><br><span class="line">  j--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(i &gt;= <span class="number">0</span>) ...</span><br><span class="line">     <span class="keyword">if</span>(j &gt;= <span class="number">0</span>) ...</span><br><span class="line">  i--;</span><br><span class="line">  j--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 单指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode102. 二叉树的层序遍历</title>
      <link href="post/e3e54639.html"/>
      <url>post/e3e54639.html</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/tao-mo-ban-bfs-he-dfs-du-ke-yi-jie-jue-by-fuxuemin/">Leetcode题解（负雪明烛），略有增删</a></strong></p><a id="more"></a><h4 id="一、套模板！BFS-和-DFS-都可以解决"><a href="#一、套模板！BFS-和-DFS-都可以解决" class="headerlink" title="一、套模板！BFS 和 DFS 都可以解决"></a>一、<strong>套模板！BFS 和 DFS 都可以解决</strong></h4><p>BFS使用队列，把每个还没有搜索到的点依次放入队列，然后再弹出队列的头部元素当做当前遍历点。BFS总共有两个模板：</p><ol><li>如果不需要确定当前遍历到了哪一层，BFS模板如下。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在while (!queue.isEmpty()) 外部入队第一个元素，或者是第一批元素(使用循环入队)</span></span><br><span class="line"><span class="comment">// 比如说把图中所有度为1的节点先入队...</span></span><br><span class="line"><span class="built_in">queue</span>.push(first);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">queue</span> 不空：</span><br><span class="line">    cur = <span class="built_in">queue</span>.pop()<span class="comment">// 该行代码位置固定，位于队列内元素while循环接下去的那一行</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// ==========================</span></span><br><span class="line">  <span class="comment">/* 划重点：这里进行主要逻辑判断, 这里举的例子为队头元素为目标值则返回步数(层数)，具体问题具体分析 */</span></span><br><span class="line">  <span class="comment">// 这部分的代码位置固定紧挨着循环访问图中所有相邻节点上面</span></span><br><span class="line">  <span class="keyword">if</span> (cur is target)</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line"><span class="comment">// ==========================  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> 节点 in cur的所有相邻节点：</span><br><span class="line">    <span class="comment">// 即if(!visited[该节点])</span></span><br><span class="line">        <span class="keyword">if</span> 该节点有效且未访问过：</span><br><span class="line">            <span class="built_in">queue</span>.push(该节点)<span class="comment">// 该行代码位置固定，位于if条件判断接下去的那一行</span></span><br><span class="line">            visited.push(该节点)</span><br></pre></td></tr></table></figure><ol start="2"><li>如果<strong>要确定当前遍历到了哪一层(对这句话的理解可以参考<a href="./Leetcode127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.md">Leetcode127-单词接龙</a>)**，BFS模板如下。这里增加了level表示当前遍历到二叉树中的哪一层了，也可以理解为在一个图中，</strong>现在已经走了多少步了，比如那些算最短距离的题目**。size表示在当前遍历层有多少个元素，也就是队列中的元素数，我们把这些元素一次性遍历完，即把当前层的所有元素都向外走了一步。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在while (!queue.isEmpty())外部入队第一个元素，或者是第一批元素(使用循环入队)</span></span><br><span class="line"><span class="comment">// 比如说把图中所有度为1的节点先入队...</span></span><br><span class="line"><span class="built_in">queue</span>.push(first);</span><br><span class="line"></span><br><span class="line">level = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">queue</span> 不空：</span><br><span class="line">    size = <span class="built_in">queue</span>.size()</span><br><span class="line">    <span class="keyword">while</span> (size --) &#123;</span><br><span class="line">        cur = <span class="built_in">queue</span>.pop()<span class="comment">// 该行代码位置固定，位于队列内元素while循环接下去的那一行</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">// ==========================</span></span><br><span class="line">        <span class="comment">/* 划重点：这里进行主要逻辑判断, 这里举的例子为队头元素为目标值则返回步数(层数)，具体问题具体分析 */</span></span><br><span class="line">        <span class="comment">// 这部分的代码位置固定紧挨着循环访问图中所有相邻节点上面</span></span><br><span class="line">        <span class="keyword">if</span> (cur is target)</span><br><span class="line">           <span class="keyword">return</span> level;  </span><br><span class="line">      <span class="comment">// ==========================  </span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> 节点 in cur的所有相邻节点：</span><br><span class="line">          <span class="comment">// 即if(!visited[该节点])</span></span><br><span class="line">            <span class="keyword">if</span> 该节点有效且未被访问过：</span><br><span class="line">                <span class="built_in">queue</span>.push(该节点)  <span class="comment">// 该行代码位置固定，位于if条件判断接下去的那一行</span></span><br><span class="line">              visited.push(该节点)</span><br><span class="line">    &#125;</span><br><span class="line">    level ++;</span><br></pre></td></tr></table></figure><p>上面两个是通用模板，在任何题目中都可以用，是要记住的！</p><h4 id="二、注：BFS里涉及到队列-queue-，一定一定有以下几个步骤"><a href="#二、注：BFS里涉及到队列-queue-，一定一定有以下几个步骤" class="headerlink" title="二、注：BFS里涉及到队列(queue)，一定一定有以下几个步骤"></a>二、<strong>注：BFS里涉及到队列(queue)，一定一定有以下几个步骤</strong></h4><ol start="0"><li><p>在while循环外部入队<strong>第一个</strong>队列元素</p></li><li><p>判队列是否为空（先入队根元素，再判断while queue 不空）</p></li><li><p>出队列首元素（cur = queue.pop()）</p></li><li><p>对出队的元素进行操作</p></li><li><p>遍历所有与队首元素相邻的元素（<strong>方向数组</strong><code>vector&lt;pair&lt;int, int&gt;&gt; dirs = &#123; &#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125; &#125;</code>常出现在二维数组遍历中）。<strong>遍历相邻节点的循环设定也是有技巧的，参考<a href="./BFS%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF.md">建图方法</a>，相邻节点和什么条件有关就依照这个条件设置循环因子，可以有多个因子，对应多层嵌套循环</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 比如时钟里与<span class="number">0</span>点相邻的有<span class="number">1</span>点和<span class="number">11</span>点，那么就把小时刻度当成循环条件，并且循环<span class="number">2</span>次；</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 比如一个字母能一次变成其他<span class="number">25</span>个字母，那么就把字母当成循环条件</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 比如一个单词通过改变其中一个字母从而转换成另一个单词，那么就把单词下标和字母当成循环条件</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; wordLen; j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 比如二维数组里改变<span class="string">&quot;九宫格&quot;</span>位置的元素</span><br><span class="line"><span class="comment">// 定义 8 个方向</span></span><br><span class="line"><span class="keyword">int</span>[] dx = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] dy = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">   <span class="keyword">int</span> newX = i + dx[k];</span><br><span class="line">   <span class="keyword">int</span> newY = j + dy[k];</span><br><span class="line">   <span class="keyword">if</span> (newX &lt; <span class="number">0</span> || newX &gt;= board.length || newY &lt; <span class="number">0</span> || newY &gt;= board[<span class="number">0</span>].length) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>（可能存在）对已遍历的元素置状态保证之后不再访问（<code>visited[i] == true</code>），并把没有访问过的元素推进队列中同时<code>visited</code>状态置为true</p></li></ol><h4 id="三、自定义公式"><a href="#三、自定义公式" class="headerlink" title="三、自定义公式"></a>三、自定义公式</h4><p><strong>BFS里能根据具体题目自定义的模板公式不多，因为大部分都是写死的代码，跟具体的题目逻辑无关，能自定义的且和逻辑简单相关(指的是单纯看题目条件就能得出)的就只有循环因子了</strong></p><ol><li>根据题目条件判断循环因子，N个循环因子对应N层嵌套循环</li><li>构造相邻节点：请与之前的根据题意判断循环因子区分开，两者的区别就好像<strong>根据条件判断循环因子进行循环就是在向周围伸出<code>触手</code>，进行了几次循环就向外伸出多少条触手，而这个创建相邻节点就像是根据题意在<code>制造一个机甲部件</code>。那么这个机甲部件长啥样呢？看其他部件长啥样就行，比如看队列里的元素是什么，如果是队列里的元素是字符串，就照猫画虎构造出字符串；如果是数字，就构造出一个数字。具体如何构造，这就得看具体逻辑了</strong>，构造完成之后就等待与触手的结合点进行拼接：<code>queue.push(该节点)</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">String word = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向周围伸出N * 26条触手</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">  <span class="keyword">char</span>[] charArray = word.toCharArray();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="string">&quot;a&quot;</span>; j &lt; <span class="string">&quot;z&quot;</span>; j++)&#123;</span><br><span class="line">    <span class="comment">// 创建一个机甲部件，观察队列里的部件长啥样，照猫画虎，假设是字符串</span></span><br><span class="line">    <span class="comment">// 则生成的也是字符串</span></span><br><span class="line">    charArray[i] = j;</span><br><span class="line">    String nextWord = String.valueOf(charArray);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 这里省略和很多代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!visited.contains(nextWord)) &#123;</span><br><span class="line">      <span class="comment">// 与触手的结合点结合</span></span><br><span class="line">      <span class="built_in">queue</span>.add(nextWord);</span><br><span class="line"></span><br><span class="line">      visited.add(nextWord);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题要求二叉树的层次遍历，所以同一层的节点应该放在一起，故使用模板二。</p><p>使用队列保存每层的所有节点，每次把队列里的原先所有节点进行出队列操作，再把每个元素的非空左右子节点进入队列。因此即可得到每层的遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (que.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">            <span class="keyword">while</span> (size --) &#123;</span><br><span class="line">                TreeNode* cur = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                <span class="keyword">if</span> (!cur) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                level.push_back(cur-&gt;val);</span><br><span class="line">                que.push(cur-&gt;left);</span><br><span class="line">                que.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (level.size() != <span class="number">0</span>) &#123;</span><br><span class="line">                res.push_back(level);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="四、更新（2020-8-27），源自Sweetiee"><a href="#四、更新（2020-8-27），源自Sweetiee" class="headerlink" title="四、更新（2020-8-27），源自Sweetiee"></a>四、更新（2020-8-27），源自<a href="https://leetcode-cn.com/problems/01-matrix/solution/2chong-bfs-xiang-jie-dp-bi-xu-miao-dong-by-sweetie/">Sweetiee</a></h4><ul><li><p>对于 <strong>「Tree 的 BFS」 （典型的「单源 BFS」）</strong> 大家都已经轻车熟路了：</p><ul><li>首先把 root 节点入队，再一层一层无脑遍历就行了。</li></ul></li><li><p>对于 <strong>「图 的 BFS」 （「多源 BFS」）</strong> 做法其实也是一样滴～，与 「Tree 的 BFS」的区别注意以下两条就 ok 辣～</p><ul><li>Tree 只有 1 个 root，而图可以有多个源点，所以首先需要把多个源点都入队；</li><li>Tree 是有向的因此不需要标识是否访问过，而对于无向图来说，必须得标志是否访问过哦！并且为了防止某个节点多次入队，需要在其入队之前就将其设置成已访问！</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
